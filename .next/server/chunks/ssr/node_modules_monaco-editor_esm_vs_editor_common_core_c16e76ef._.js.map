{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AACvF,MAAM,wBAAwB;IACjC,SAAS;IACT,YAAY;IACZ,cAAc;IACd,mBAAmB;IACnB,oBAAoB;IACpB,wBAAwB;IACxB,gCAAgC;QAC5B,SAAS;QACT,oCAAoC;IACxC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/position.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n    toJSON() {\n        return {\n            lineNumber: this.lineNumber,\n            column: this.column\n        };\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F;;CAEC;;;AACM,MAAM;IACT,YAAY,UAAU,EAAE,MAAM,CAAE;QAC5B,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,MAAM,GAAG;IAClB;IACA;;;;;KAKC,GACD,KAAK,gBAAgB,IAAI,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,MAAM,EAAE;QAC3D,IAAI,kBAAkB,IAAI,CAAC,UAAU,IAAI,cAAc,IAAI,CAAC,MAAM,EAAE;YAChE,OAAO,IAAI;QACf,OACK;YACD,OAAO,IAAI,SAAS,eAAe;QACvC;IACJ;IACA;;;;;KAKC,GACD,MAAM,kBAAkB,CAAC,EAAE,cAAc,CAAC,EAAE;QACxC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,iBAAiB,IAAI,CAAC,MAAM,GAAG;IACtE;IACA;;KAEC,GACD,OAAO,KAAK,EAAE;QACV,OAAO,SAAS,MAAM,CAAC,IAAI,EAAE;IACjC;IACA;;KAEC,GACD,OAAO,OAAO,CAAC,EAAE,CAAC,EAAE;QAChB,IAAI,CAAC,KAAK,CAAC,GAAG;YACV,OAAO;QACX;QACA,OAAQ,CAAC,CAAC,KACN,CAAC,CAAC,KACF,EAAE,UAAU,KAAK,EAAE,UAAU,IAC7B,EAAE,MAAM,KAAK,EAAE,MAAM;IAC7B;IACA;;;KAGC,GACD,SAAS,KAAK,EAAE;QACZ,OAAO,SAAS,QAAQ,CAAC,IAAI,EAAE;IACnC;IACA;;;KAGC,GACD,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE;QAClB,IAAI,EAAE,UAAU,GAAG,EAAE,UAAU,EAAE;YAC7B,OAAO;QACX;QACA,IAAI,EAAE,UAAU,GAAG,EAAE,UAAU,EAAE;YAC7B,OAAO;QACX;QACA,OAAO,EAAE,MAAM,GAAG,EAAE,MAAM;IAC9B;IACA;;;KAGC,GACD,gBAAgB,KAAK,EAAE;QACnB,OAAO,SAAS,eAAe,CAAC,IAAI,EAAE;IAC1C;IACA;;;KAGC,GACD,OAAO,gBAAgB,CAAC,EAAE,CAAC,EAAE;QACzB,IAAI,EAAE,UAAU,GAAG,EAAE,UAAU,EAAE;YAC7B,OAAO;QACX;QACA,IAAI,EAAE,UAAU,GAAG,EAAE,UAAU,EAAE;YAC7B,OAAO;QACX;QACA,OAAO,EAAE,MAAM,IAAI,EAAE,MAAM;IAC/B;IACA;;KAEC,GACD,OAAO,QAAQ,CAAC,EAAE,CAAC,EAAE;QACjB,MAAM,cAAc,EAAE,UAAU,GAAG;QACnC,MAAM,cAAc,EAAE,UAAU,GAAG;QACnC,IAAI,gBAAgB,aAAa;YAC7B,MAAM,UAAU,EAAE,MAAM,GAAG;YAC3B,MAAM,UAAU,EAAE,MAAM,GAAG;YAC3B,OAAO,UAAU;QACrB;QACA,OAAO,cAAc;IACzB;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAI,SAAS,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM;IACpD;IACA;;KAEC,GACD,WAAW;QACP,OAAO,MAAM,IAAI,CAAC,UAAU,GAAG,MAAM,IAAI,CAAC,MAAM,GAAG;IACvD;IACA,MAAM;IACN;;KAEC,GACD,OAAO,KAAK,GAAG,EAAE;QACb,OAAO,IAAI,SAAS,IAAI,UAAU,EAAE,IAAI,MAAM;IAClD;IACA;;KAEC,GACD,OAAO,YAAY,GAAG,EAAE;QACpB,OAAQ,OACA,OAAO,IAAI,UAAU,KAAK,YAC1B,OAAO,IAAI,MAAM,KAAK;IAClC;IACA,SAAS;QACL,OAAO;YACH,YAAY,IAAI,CAAC,UAAU;YAC3B,QAAQ,IAAI,CAAC,MAAM;QACvB;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 290, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 773, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 904, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F;;AAIO,MAAM;IACT,YAAY,aAAa,CAAE;QACvB,MAAM,eAAe,CAAA,GAAA,uKAAA,CAAA,UAAO,AAAD,EAAE;QAC7B,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,SAAS,GAAG,oBAAoB,eAAe,CAAC;QACrD,IAAI,CAAC,IAAI,GAAG,IAAI;IACpB;IACA,OAAO,gBAAgB,YAAY,EAAE;QACjC,MAAM,WAAW,IAAI,WAAW;QAChC,SAAS,IAAI,CAAC;QACd,OAAO;IACX;IACA,IAAI,QAAQ,EAAE,MAAM,EAAE;QAClB,MAAM,QAAQ,CAAA,GAAA,uKAAA,CAAA,UAAO,AAAD,EAAE;QACtB,IAAI,YAAY,KAAK,WAAW,KAAK;YACjC,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG;QAC/B,OACK;YACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU;QAC5B;IACJ;IACA,IAAI,QAAQ,EAAE;QACV,IAAI,YAAY,KAAK,WAAW,KAAK;YACjC,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS;QACnC,OACK;YACD,OAAQ,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,aAAa,IAAI,CAAC,aAAa;QACzD;IACJ;IACA,QAAQ;QACJ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;QACtC,IAAI,CAAC,IAAI,CAAC,KAAK;IACnB;AACJ;AACO,MAAM;IACT,aAAc;QACV,IAAI,CAAC,OAAO,GAAG,IAAI,oBAAoB,EAAE,iBAAiB;IAC9D;IACA,IAAI,QAAQ,EAAE;QACV,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,gBAAgB;IACjD;IACA,IAAI,QAAQ,EAAE;QACV,OAAQ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,gBAAgB;IAC7D;IACA,QAAQ;QACJ,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK;IAC7B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators, intlSegmenterLocales) {\n        super(0 /* WordCharacterClass.Regular */);\n        this._segmenter = null;\n        this._cachedLine = null;\n        this._cachedSegments = [];\n        this.intlSegmenterLocales = intlSegmenterLocales;\n        if (this.intlSegmenterLocales.length > 0) {\n            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n        }\n        else {\n            this._segmenter = null;\n        }\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\n        let candidate = null;\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n            if (segment.index > offset) {\n                break;\n            }\n            candidate = segment;\n        }\n        return candidate;\n    }\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n            if (segment.index < offset) {\n                continue;\n            }\n            return segment;\n        }\n        return null;\n    }\n    _getIntlSegmenterWordsOnLine(line) {\n        if (!this._segmenter) {\n            return [];\n        }\n        // Check if the line has changed from the previous call\n        if (this._cachedLine === line) {\n            return this._cachedSegments;\n        }\n        // Update the cache with the new line\n        this._cachedLine = line;\n        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n        return this._cachedSegments;\n    }\n    _filterWordSegments(segments) {\n        const result = [];\n        for (const segment of segments) {\n            if (this._isWordLike(segment)) {\n                result.push(segment);\n            }\n        }\n        return result;\n    }\n    _isWordLike(segment) {\n        if (segment.isWordLike) {\n            return true;\n        }\n        return false;\n    }\n}\nconst wordClassifierCache = new LRUCache(10);\nexport function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n    let result = wordClassifierCache.get(key);\n    if (!result) {\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n        wordClassifierCache.set(key, result);\n    }\n    return result;\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F;AACA;;;AACO,MAAM,gCAAgC,gMAAA,CAAA,sBAAmB;IAC5D,YAAY,cAAc,EAAE,oBAAoB,CAAE;QAC9C,KAAK,CAAC,EAAE,8BAA8B;QACtC,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,eAAe,GAAG,EAAE;QACzB,IAAI,CAAC,oBAAoB,GAAG;QAC5B,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,GAAG;YACtC,IAAI,CAAC,UAAU,GAAG,IAAI,KAAK,SAAS,CAAC,IAAI,CAAC,oBAAoB,EAAE;gBAAE,aAAa;YAAO;QAC1F,OACK;YACD,IAAI,CAAC,UAAU,GAAG;QACtB;QACA,IAAK,IAAI,IAAI,GAAG,MAAM,eAAe,MAAM,EAAE,IAAI,KAAK,IAAK;YACvD,IAAI,CAAC,GAAG,CAAC,eAAe,UAAU,CAAC,IAAI,EAAE,oCAAoC;QACjF;QACA,IAAI,CAAC,GAAG,CAAC,GAAG,kBAAkB,KAAI,EAAE,iCAAiC;QACrE,IAAI,CAAC,GAAG,CAAC,EAAE,gBAAgB,KAAI,EAAE,iCAAiC;IACtE;IACA,iCAAiC,IAAI,EAAE,MAAM,EAAE;QAC3C,IAAI,YAAY;QAChB,KAAK,MAAM,WAAW,IAAI,CAAC,4BAA4B,CAAC,MAAO;YAC3D,IAAI,QAAQ,KAAK,GAAG,QAAQ;gBACxB;YACJ;YACA,YAAY;QAChB;QACA,OAAO;IACX;IACA,gCAAgC,WAAW,EAAE,MAAM,EAAE;QACjD,KAAK,MAAM,WAAW,IAAI,CAAC,4BAA4B,CAAC,aAAc;YAClE,IAAI,QAAQ,KAAK,GAAG,QAAQ;gBACxB;YACJ;YACA,OAAO;QACX;QACA,OAAO;IACX;IACA,6BAA6B,IAAI,EAAE;QAC/B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,OAAO,EAAE;QACb;QACA,uDAAuD;QACvD,IAAI,IAAI,CAAC,WAAW,KAAK,MAAM;YAC3B,OAAO,IAAI,CAAC,eAAe;QAC/B;QACA,qCAAqC;QACrC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACxE,OAAO,IAAI,CAAC,eAAe;IAC/B;IACA,oBAAoB,QAAQ,EAAE;QAC1B,MAAM,SAAS,EAAE;QACjB,KAAK,MAAM,WAAW,SAAU;YAC5B,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU;gBAC3B,OAAO,IAAI,CAAC;YAChB;QACJ;QACA,OAAO;IACX;IACA,YAAY,OAAO,EAAE;QACjB,IAAI,QAAQ,UAAU,EAAE;YACpB,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACA,MAAM,sBAAsB,IAAI,sKAAA,CAAA,WAAQ,CAAC;AAClC,SAAS,wBAAwB,cAAc,EAAE,oBAAoB;IACxE,MAAM,MAAM,GAAG,eAAe,CAAC,EAAE,qBAAqB,IAAI,CAAC,MAAM;IACjE,IAAI,SAAS,oBAAoB,GAAG,CAAC;IACrC,IAAI,CAAC,QAAQ;QACT,SAAS,IAAI,wBAAwB,gBAAgB;QACrD,oBAAoB,GAAG,CAAC,KAAK;IACjC;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1060, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    static ofStartAndLength(start, length) {\n        return new OffsetRange(start, start + length);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nexport class OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1253, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1550, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n    static { this.zero = new TextLength(0, 0); }\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;;;AAIO,MAAM;IACT,MAAO;QAAE,IAAI,CAAC,IAAI,GAAG,IAAI,WAAW,GAAG;IAAI,CAAC;IAC5C,OAAO,iBAAiB,SAAS,EAAE,SAAS,EAAE;QAC1C,IAAI,UAAU,UAAU,KAAK,UAAU,UAAU,EAAE;YAC/C,OAAO,IAAI,WAAW,GAAG,UAAU,MAAM,GAAG,UAAU,MAAM;QAChE,OACK;YACD,OAAO,IAAI,WAAW,UAAU,UAAU,GAAG,UAAU,UAAU,EAAE,UAAU,MAAM,GAAG;QAC1F;IACJ;IACA,OAAO,QAAQ,KAAK,EAAE;QAClB,OAAO,WAAW,gBAAgB,CAAC,MAAM,gBAAgB,IAAI,MAAM,cAAc;IACrF;IACA,OAAO,OAAO,IAAI,EAAE;QAChB,IAAI,OAAO;QACX,IAAI,SAAS;QACb,KAAK,MAAM,KAAK,KAAM;YAClB,IAAI,MAAM,MAAM;gBACZ;gBACA,SAAS;YACb,OACK;gBACD;YACJ;QACJ;QACA,OAAO,IAAI,WAAW,MAAM;IAChC;IACA,YAAY,SAAS,EAAE,WAAW,CAAE;QAChC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,uBAAuB,KAAK,EAAE;QAC1B,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,SAAS,EAAE;YACpC,OAAO,IAAI,CAAC,SAAS,GAAG,MAAM,SAAS;QAC3C;QACA,OAAO,IAAI,CAAC,WAAW,IAAI,MAAM,WAAW;IAChD;IACA,YAAY,aAAa,EAAE;QACvB,IAAI,IAAI,CAAC,SAAS,KAAK,GAAG;YACtB,OAAO,IAAI,kLAAA,CAAA,QAAK,CAAC,cAAc,UAAU,EAAE,cAAc,MAAM,EAAE,cAAc,UAAU,EAAE,cAAc,MAAM,GAAG,IAAI,CAAC,WAAW;QACtI,OACK;YACD,OAAO,IAAI,kLAAA,CAAA,QAAK,CAAC,cAAc,UAAU,EAAE,cAAc,MAAM,EAAE,cAAc,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,GAAG;QACnI;IACJ;IACA,cAAc,QAAQ,EAAE;QACpB,IAAI,IAAI,CAAC,SAAS,KAAK,GAAG;YACtB,OAAO,IAAI,qLAAA,CAAA,WAAQ,CAAC,SAAS,UAAU,EAAE,SAAS,MAAM,GAAG,IAAI,CAAC,WAAW;QAC/E,OACK;YACD,OAAO,IAAI,qLAAA,CAAA,WAAQ,CAAC,SAAS,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,GAAG;QACjF;IACJ;IACA,WAAW;QACP,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE;IAClD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js"],"sourcesContent":["import { OffsetRange } from './offsetRange.js';\nimport { TextLength } from './textLength.js';\nexport class PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,MAAM;IACT,YAAY,IAAI,CAAE;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,wBAAwB,GAAG,EAAE;QAClC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC;QACnC,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAClC,IAAI,KAAK,MAAM,CAAC,OAAO,MAAM;gBACzB,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI;YAC3C;QACJ;IACJ;IACA,UAAU,QAAQ,EAAE;QAChB,OAAO,IAAI,CAAC,wBAAwB,CAAC,SAAS,UAAU,GAAG,EAAE,GAAG,SAAS,MAAM,GAAG;IACtF;IACA,eAAe,KAAK,EAAE;QAClB,OAAO,IAAI,wLAAA,CAAA,cAAW,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,gBAAgB,KAAK,IAAI,CAAC,SAAS,CAAC,MAAM,cAAc;IACxG;IACA,IAAI,aAAa;QACb,MAAM,UAAU,IAAI,CAAC,wBAAwB,CAAC,MAAM,GAAG;QACvD,OAAO,IAAI,uLAAA,CAAA,aAAU,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ;IAC5F;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1656, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nexport class TextEdit {\n    constructor(edits) {\n        this.edits = edits;\n        assertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = new Position(1, 1);\n        for (const edit of this.edits) {\n            const editRange = edit.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += edit.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = new StringText(str);\n        return this.apply(strText);\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const edit of this.edits) {\n            const textLength = TextLength.ofText(edit.text);\n            const newRangeStart = Position.lift({\n                lineNumber: edit.range.startLineNumber + lineOffset,\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n            columnOffset = newRange.endColumn - edit.range.endColumn;\n            previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n        return newRanges;\n    }\n}\nexport class SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n    toSingleEditOperation() {\n        return {\n            range: this.range,\n            text: this.text,\n        };\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n        return Range.fromPositions(end, end);\n    }\n    else if (!start.isBeforeOrEqual(end)) {\n        throw new BugIndicatingError('start must be before end');\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\nexport class AbstractText {\n    get endPositionExclusive() {\n        return this.length.addToPosition(new Position(1, 1));\n    }\n}\nexport class StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = new PositionOffsetTransformer(this.value);\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1770, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AACvF,SAAS,SAAS,IAAI;IACzB,IAAI,WAAW;IACf,IAAI,kBAAkB;IACtB,IAAI,gBAAgB;IACpB,IAAI,MAAM,EAAE,qBAAqB;IACjC,IAAK,IAAI,IAAI,GAAG,MAAM,KAAK,MAAM,EAAE,IAAI,KAAK,IAAK;QAC7C,MAAM,MAAM,KAAK,UAAU,CAAC;QAC5B,IAAI,QAAQ,GAAG,2BAA2B,KAAI;YAC1C,IAAI,aAAa,GAAG;gBAChB,kBAAkB;YACtB;YACA;YACA,IAAI,IAAI,IAAI,OAAO,KAAK,UAAU,CAAC,IAAI,OAAO,GAAG,qBAAqB,KAAI;gBACtE,eAAe;gBACf,OAAO,EAAE,kBAAkB;gBAC3B,KAAK,UAAU;YACnB,OACK;gBACD,aAAa;gBACb,OAAO,EAAE,qBAAqB;YAClC;YACA,gBAAgB,IAAI;QACxB,OACK,IAAI,QAAQ,GAAG,qBAAqB,KAAI;YACzC,aAAa;YACb,OAAO,EAAE,gBAAgB;YACzB,IAAI,aAAa,GAAG;gBAChB,kBAAkB;YACtB;YACA;YACA,gBAAgB,IAAI;QACxB;IACJ;IACA,IAAI,aAAa,GAAG;QAChB,kBAAkB,KAAK,MAAM;IACjC;IACA,OAAO;QAAC;QAAU;QAAiB,KAAK,MAAM,GAAG;QAAe;KAAI;AACxE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1823, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;;AACO,MAAM;IACT,OAAO,OAAO,QAAQ,EAAE,IAAI,EAAE;QAC1B,OAAO;YACH,OAAO,IAAI,kLAAA,CAAA,QAAK,CAAC,SAAS,UAAU,EAAE,SAAS,MAAM,EAAE,SAAS,UAAU,EAAE,SAAS,MAAM;YAC3F,MAAM;YACN,kBAAkB;QACtB;IACJ;IACA,OAAO,OAAO,KAAK,EAAE;QACjB,OAAO;YACH,OAAO;YACP,MAAM;QACV;IACJ;IACA,OAAO,QAAQ,KAAK,EAAE,IAAI,EAAE;QACxB,OAAO;YACH,OAAO;YACP,MAAM;QACV;IACJ;IACA,OAAO,YAAY,KAAK,EAAE,IAAI,EAAE;QAC5B,OAAO;YACH,OAAO;YACP,MAAM;YACN,kBAAkB;QACtB;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1865, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', null, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'));\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'));\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', editorCursorForeground, nls.localize('editorMultiCursorPrimaryForeground', 'Color of the primary editor cursor when multiple cursors are present.'));\nexport const editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', editorCursorBackground, nls.localize('editorMultiCursorPrimaryBackground', 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', editorCursorForeground, nls.localize('editorMultiCursorSecondaryForeground', 'Color of secondary editor cursors when multiple cursors are present.'));\nexport const editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', editorCursorBackground, nls.localize('editorMultiCursorSecondaryBackground', 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', editorWhitespaces, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', editorWhitespaces, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', deprecatedEditorIndentGuides, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', '#00000000', nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', '#00000000', nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', '#00000000', nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', '#00000000', nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', '#00000000', nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', deprecatedEditorActiveIndentGuides, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', '#00000000', nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', '#00000000', nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', '#00000000', nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', '#00000000', nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', '#00000000', nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', deprecatedEditorActiveLineNumber, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', null, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', editorBackground, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', null, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', rulerRangeDefault, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', '#00000000', nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', '#00000000', nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', '#00000000', nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: 'new Color(new RGBA(255, 50, 50, 1))', hcLight: '#B5200D' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', '#00000000', nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', '#00000000', nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', '#00000000', nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', '#00000000', nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', '#00000000', nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', '#00000000', nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', '#00000000', nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', '#00000000', nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', '#00000000', nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', '#00000000', nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', '#00000000', nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', '#00000000', nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', editorWarningForeground, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', editorWarningBackground, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2158, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;;AAiBO,MAAM;IACT,OAAO,mBAAmB,SAAS,EAAE,aAAa,EAAE,OAAO,EAAE;QACzD,IAAI,cAAc,EAAE,gBAAgB,KAAI;YACpC,OAAO,cAAc,iBAAiB,CAAC,eAAe;QAC1D;QACA,IAAI,CAAA,GAAA,0KAAA,CAAA,uBAA4B,AAAD,EAAE,cAAc,CAAA,GAAA,0KAAA,CAAA,mBAAwB,AAAD,EAAE,YAAY;YAChF,OAAO,gBAAgB;QAC3B;QACA,OAAO,gBAAgB;IAC3B;IACA;;;KAGC,GACD,OAAO,wBAAwB,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE;QACzD,MAAM,UAAU,KAAK,GAAG,CAAC,SAAS,GAAG,YAAY,MAAM;QACvD,MAAM,OAAO,YAAY,SAAS,CAAC,GAAG;QACtC,MAAM,WAAW,IAAI,0KAAA,CAAA,mBAAwB,CAAC;QAC9C,IAAI,SAAS;QACb,MAAO,CAAC,SAAS,GAAG,GAAI;YACpB,MAAM,YAAY,CAAA,GAAA,0KAAA,CAAA,mBAAwB,AAAD,EAAE,MAAM,SAAS,SAAS,MAAM;YACzE,SAAS,kBAAkB;YAC3B,SAAS,IAAI,CAAC,kBAAkB,CAAC,WAAW,QAAQ;QACxD;QACA,OAAO;IACX;IACA;;;KAGC,GACD,OAAO,wBAAwB,WAAW,EAAE,aAAa,EAAE,OAAO,EAAE;QAChE,IAAI,iBAAiB,GAAG;YACpB,OAAO;QACX;QACA,MAAM,oBAAoB,YAAY,MAAM;QAC5C,MAAM,WAAW,IAAI,0KAAA,CAAA,mBAAwB,CAAC;QAC9C,IAAI,sBAAsB;QAC1B,IAAI,eAAe;QACnB,MAAO,CAAC,SAAS,GAAG,GAAI;YACpB,MAAM,YAAY,CAAA,GAAA,0KAAA,CAAA,mBAAwB,AAAD,EAAE,aAAa,mBAAmB,SAAS,MAAM;YAC1F,SAAS,kBAAkB;YAC3B,MAAM,qBAAqB,IAAI,CAAC,kBAAkB,CAAC,WAAW,qBAAqB;YACnF,MAAM,cAAc,SAAS,MAAM,GAAG;YACtC,IAAI,sBAAsB,eAAe;gBACrC,MAAM,cAAc,gBAAgB;gBACpC,MAAM,aAAa,qBAAqB;gBACxC,IAAI,aAAa,aAAa;oBAC1B,OAAO;gBACX,OACK;oBACD,OAAO;gBACX;YACJ;YACA,sBAAsB;YACtB,eAAe;QACnB;QACA,2BAA2B;QAC3B,OAAO,oBAAoB;IAC/B;IACA;;;KAGC,GACD,OAAO,kBAAkB,aAAa,EAAE,OAAO,EAAE;QAC7C,OAAO,gBAAgB,UAAU,gBAAgB;IACrD;IACA;;;KAGC,GACD,OAAO,kBAAkB,aAAa,EAAE,UAAU,EAAE;QAChD,OAAO,gBAAgB,aAAa,gBAAgB;IACxD;IACA;;;KAGC,GACD,OAAO,kBAAkB,MAAM,EAAE,OAAO,EAAE;QACtC,OAAO,KAAK,GAAG,CAAC,GAAG,SAAS,IAAI,CAAC,SAAS,CAAC,IAAI;IACnD;IACA;;;KAGC,GACD,OAAO,kBAAkB,MAAM,EAAE,UAAU,EAAE;QACzC,OAAO,KAAK,GAAG,CAAC,GAAG,SAAS,IAAI,CAAC,SAAS,CAAC,IAAI;IACnD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2253, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;;;AACA,SAAS,oCAAoC,GAAG,EAAE,UAAU,EAAE,YAAY;IACtE,IAAI,YAAY;IAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;QACjC,IAAI,IAAI,MAAM,CAAC,OAAO,MAAM;YACxB,YAAY,0LAAA,CAAA,gBAAa,CAAC,iBAAiB,CAAC,WAAW;QAC3D,OACK;YACD;QACJ;IACJ;IACA,IAAI,SAAS;IACb,IAAI,CAAC,cAAc;QACf,MAAM,UAAU,KAAK,KAAK,CAAC,YAAY;QACvC,YAAY,YAAY;QACxB,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,IAAK;YAC9B,UAAU;QACd;IACJ;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;QAChC,UAAU;IACd;IACA,OAAO;AACX;AACO,SAAS,qBAAqB,GAAG,EAAE,UAAU,EAAE,YAAY;IAC9D,IAAI,0BAA0B,CAAA,GAAA,0KAAA,CAAA,0BAA+B,AAAD,EAAE;IAC9D,IAAI,4BAA4B,CAAC,GAAG;QAChC,0BAA0B,IAAI,MAAM;IACxC;IACA,OAAO,oCAAoC,IAAI,SAAS,CAAC,GAAG,0BAA0B,YAAY,gBAAgB,IAAI,SAAS,CAAC;AACpI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2548, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    static { this.Empty = new RGBA8(0, 0, 0, 0); }\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F;;;CAGC;;;AACM,MAAM;IACT,MAAO;QAAE,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG;IAAI,CAAC;IAC9C,YAAY,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;QACpB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;QACtB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;QACtB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;QACtB,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;IAC1B;IACA,OAAO,KAAK,EAAE;QACV,OAAQ,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC,IACnB,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC,IAClB,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC,IAClB,IAAI,CAAC,CAAC,KAAK,MAAM,CAAC;IAC7B;IACA,OAAO,OAAO,CAAC,EAAE;QACb,IAAI,IAAI,GAAG;YACP,OAAO;QACX;QACA,IAAI,IAAI,KAAK;YACT,OAAO;QACX;QACA,OAAO,IAAI;IACf;AACJ","ignoreList":[0],"debugId":null}}]
}