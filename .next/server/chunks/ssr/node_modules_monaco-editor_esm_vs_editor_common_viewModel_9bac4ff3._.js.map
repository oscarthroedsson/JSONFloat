{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    static { this._INSTANCE = null; }\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* ColorId.DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* ColorId.DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;AACA;AACA;;;;;AACO,MAAM,kCAAkC,4KAAA,CAAA,aAAU;IACrD,MAAO;QAAE,IAAI,CAAC,SAAS,GAAG;IAAM,CAAC;IACjC,OAAO,cAAc;QACjB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,IAAI,CAAC,SAAS,GAAG,CAAA,GAAA,4KAAA,CAAA,kBAAe,AAAD,EAAE,IAAI;QACzC;QACA,OAAO,IAAI,CAAC,SAAS;IACzB;IACA,aAAc;QACV,KAAK;QACL,IAAI,CAAC,YAAY,GAAG,IAAI,wKAAA,CAAA,UAAO;QAC/B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK;QAC1C,IAAI,CAAC,eAAe;QACpB,IAAI,CAAC,SAAS,CAAC,8KAAA,CAAA,uBAAoB,CAAC,WAAW,CAAC,CAAA;YAC5C,IAAI,EAAE,eAAe,EAAE;gBACnB,IAAI,CAAC,eAAe;YACxB;QACJ;IACJ;IACA,kBAAkB;QACd,MAAM,WAAW,8KAAA,CAAA,uBAAoB,CAAC,WAAW;QACjD,IAAI,CAAC,UAAU;YACX,IAAI,CAAC,OAAO,GAAG;gBAAC,iLAAA,CAAA,QAAK,CAAC,KAAK;aAAC;YAC5B,IAAI,CAAC,kBAAkB,GAAG;YAC1B;QACJ;QACA,IAAI,CAAC,OAAO,GAAG;YAAC,iLAAA,CAAA,QAAK,CAAC,KAAK;SAAC;QAC5B,IAAK,IAAI,UAAU,GAAG,UAAU,SAAS,MAAM,EAAE,UAAW;YACxD,MAAM,SAAS,QAAQ,CAAC,QAAQ,CAAC,IAAI;YACrC,8BAA8B;YAC9B,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,IAAI,iLAAA,CAAA,QAAK,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,KAAK,KAAK,CAAC,OAAO,CAAC,GAAG;QAC1F;QACA,MAAM,uBAAuB,QAAQ,CAAC,EAAE,6BAA6B,IAAG,CAAC,oBAAoB;QAC7F,IAAI,CAAC,kBAAkB,GAAG,wBAAwB;QAClD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;IAC3B;IACA,SAAS,OAAO,EAAE;QACd,IAAI,UAAU,KAAK,WAAW,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YAC/C,yCAAyC;YACzC,UAAU,EAAE,6BAA6B;QAC7C;QACA,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ;IAChC;IACA,oBAAoB;QAChB,OAAO,IAAI,CAAC,kBAAkB;IAClC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, heightInLines, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.heightInLines = heightInLines;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                if (a.heightInLines === b.heightInLines) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.heightInLines - b.heightInLines;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* Constants.MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const offset1 = this._getVerticalOffsetForLine(zone.startLineNumber);\n            const offset2 = (zone.heightInLines === 0\n                ? this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight\n                : offset1 + zone.heightInLines * lineHeight);\n            const y1 = Math.floor(heightRatio * offset1);\n            const y2 = Math.floor(heightRatio * offset2);\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorTheme } from '../editorTheme.js';\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.viewModel = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.viewModel.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.viewModel.removeViewEventHandler(eventHandler);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;;AACO,MAAM;IACT,YAAY,aAAa,EAAE,KAAK,EAAE,KAAK,CAAE;QACrC,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,KAAK,GAAG,IAAI,gLAAA,CAAA,cAAW,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,UAAU,GAAG,MAAM,UAAU;IACtC;IACA,gBAAgB,YAAY,EAAE;QAC1B,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC;IACvC;IACA,mBAAmB,YAAY,EAAE;QAC7B,IAAI,CAAC,SAAS,CAAC,sBAAsB,CAAC;IAC1C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(135 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(134 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (!isKeepAll && prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (!isKeepAll && charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */, false, true);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._getDecorationsInRange(range, true, false).decorations;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange, false, false);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    getInlineDecorationsOnLine(lineNumber, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n        return this._getDecorationsInRange(range, onlyMinimapDecorations, onlyMarginDecorations).inlineDecorations[0];\n    }\n    _getDecorationsInRange(viewRange, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options), onlyMinimapDecorations, onlyMarginDecorations);\n        const startLineNumber = viewRange.startLineNumber;\n        const endLineNumber = viewRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* StandardTokenType.Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.tokenization.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 906, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* PositionAffinity.None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    static { this.INSTANCE = new IdentityModelLineProjection(); }\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    static { this.INSTANCE = new HiddenModelLineProjection(); }\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nconst _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1245, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        const equalWordBreak = (this.wordBreak === wordBreak);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        if (belowHiddenRanges) {\n            while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex++;\n                lineIndexChanged = true;\n            }\n        }\n        else {\n            while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            // TODO@alexdima@hediet this isn't soo pretty\n            return new Position(allowZeroLineNumber ? 0 : 1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            if (belowHiddenRanges) {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n            }\n            else {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n            }\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2223, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/glyphLanesModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlyphMarginLane } from '../model.js';\nconst MAX_LANE = GlyphMarginLane.Right;\nexport class GlyphMarginLanesModel {\n    constructor(maxLine) {\n        this.persist = 0;\n        this._requiredLanes = 1; // always render at least one lane\n        this.lanes = new Uint8Array(Math.ceil(((maxLine + 1) * MAX_LANE) / 8));\n    }\n    reset(maxLine) {\n        const bytes = Math.ceil(((maxLine + 1) * MAX_LANE) / 8);\n        if (this.lanes.length < bytes) {\n            this.lanes = new Uint8Array(bytes);\n        }\n        else {\n            this.lanes.fill(0);\n        }\n        this._requiredLanes = 1;\n    }\n    get requiredLanes() {\n        return this._requiredLanes;\n    }\n    push(lane, range, persist) {\n        if (persist) {\n            this.persist |= (1 << (lane - 1));\n        }\n        for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n            const bit = (MAX_LANE * i) + (lane - 1);\n            this.lanes[bit >>> 3] |= (1 << (bit % 8));\n            this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(i));\n        }\n    }\n    getLanesAtLine(lineNumber) {\n        const lanes = [];\n        let bit = MAX_LANE * lineNumber;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                lanes.push(i + 1);\n            }\n            bit++;\n        }\n        return lanes.length ? lanes : [GlyphMarginLane.Center];\n    }\n    countAtLine(lineNumber) {\n        let bit = MAX_LANE * lineNumber;\n        let count = 0;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                count++;\n            }\n            bit++;\n        }\n        return count;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;;AACA,MAAM,WAAW,0KAAA,CAAA,kBAAe,CAAC,KAAK;AAC/B,MAAM;IACT,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,cAAc,GAAG,GAAG,kCAAkC;QAC3D,IAAI,CAAC,KAAK,GAAG,IAAI,WAAW,KAAK,IAAI,CAAC,AAAC,CAAC,UAAU,CAAC,IAAI,WAAY;IACvE;IACA,MAAM,OAAO,EAAE;QACX,MAAM,QAAQ,KAAK,IAAI,CAAC,AAAC,CAAC,UAAU,CAAC,IAAI,WAAY;QACrD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,OAAO;YAC3B,IAAI,CAAC,KAAK,GAAG,IAAI,WAAW;QAChC,OACK;YACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QACpB;QACA,IAAI,CAAC,cAAc,GAAG;IAC1B;IACA,IAAI,gBAAgB;QAChB,OAAO,IAAI,CAAC,cAAc;IAC9B;IACA,KAAK,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;QACvB,IAAI,SAAS;YACT,IAAI,CAAC,OAAO,IAAK,KAAM,OAAO;QAClC;QACA,IAAK,IAAI,IAAI,MAAM,eAAe,EAAE,KAAK,MAAM,aAAa,EAAE,IAAK;YAC/D,MAAM,MAAM,AAAC,WAAW,IAAK,CAAC,OAAO,CAAC;YACtC,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAK,KAAM,MAAM;YACtC,IAAI,CAAC,cAAc,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,WAAW,CAAC;QACzE;IACJ;IACA,eAAe,UAAU,EAAE;QACvB,MAAM,QAAQ,EAAE;QAChB,IAAI,MAAM,WAAW;QACrB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;YAC/B,IAAI,IAAI,CAAC,OAAO,GAAI,KAAK,KAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAI,KAAM,MAAM,GAAK;gBACrE,MAAM,IAAI,CAAC,IAAI;YACnB;YACA;QACJ;QACA,OAAO,MAAM,MAAM,GAAG,QAAQ;YAAC,0KAAA,CAAA,kBAAe,CAAC,MAAM;SAAC;IAC1D;IACA,YAAY,UAAU,EAAE;QACpB,IAAI,MAAM,WAAW;QACrB,IAAI,QAAQ;QACZ,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;YAC/B,IAAI,IAAI,CAAC,OAAO,GAAI,KAAK,KAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAI,KAAM,MAAM,GAAK;gBACrE;YACJ;YACA;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2291, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nimport { GlyphMarginLanesModel } from './glyphLanesModel.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView, _transactionalTarget) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._attachedView = _attachedView;\n        this._transactionalTarget = _transactionalTarget;\n        this.hiddenAreasModel = new HiddenAreasModel();\n        this.previousHiddenAreas = [];\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        this.glyphLanes = new GlyphMarginLanesModel(0);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(140 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(139 /* EditorOption.wrappingIndent */);\n            const wordBreak = options.get(130 /* EditorOption.wordBreak */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._handleVisibleLinesChanged();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    getModelVisibleRanges() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        return modelVisibleRanges;\n    }\n    visibleLinesStabilized() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, true);\n    }\n    _handleVisibleLinesChanged() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, false);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _captureStableViewport() {\n        // We might need to restore the current start view range, so save it (if available)\n        // But only if the scroll position is not at the top of the file\n        if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n        }\n        return new StableViewport(null, 0);\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        const stableViewport = this._captureStableViewport();\n        const options = this._configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(140 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(139 /* EditorOption.wrappingIndent */);\n        const wordBreak = options.get(130 /* EditorOption.wordBreak */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(92 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        if (e.hasChanged(99 /* EditorOption.renderValidationDecorations */)) {\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._handleVisibleLinesChanged();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges, source) {\n        this.hiddenAreasModel.setHiddenAreas(source, ranges);\n        const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n        if (mergedRanges === this.previousHiddenAreas) {\n            return;\n        }\n        this.previousHiddenAreas = mergedRanges;\n        const stableViewport = this._captureStableViewport();\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n            const firstModelLineInViewPort = stableViewport.viewportStartModelPosition?.lineNumber;\n            const firstModelLineIsHidden = firstModelLineInViewPort && mergedRanges.some(range => range.startLineNumber <= firstModelLineInViewPort && firstModelLineInViewPort <= range.endLineNumber);\n            if (!firstModelLineIsHidden) {\n                stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(146 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(67 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._decorations.getMinimapDecorationsInRange(range);\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            opts1?.invalidateCachedColor();\n            const opts2 = decoration.options.minimap;\n            opts2?.invalidateCachedColor();\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getValueLengthInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueLengthInRange(modelRange, eol);\n    }\n    modifyPosition(position, offset) {\n        const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n        const resultModelPosition = this.model.modifyPosition(modelPosition, offset);\n        return this.coordinatesConverter.convertModelPositionToViewPosition(resultModelPosition);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealAllCursors(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealAll(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        return this._transactionalTarget.batchChanges(() => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                return callback(eventsCollector);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        });\n    }\n    batchEvents(callback) {\n        this._withViewEventsCollector(() => { callback(); });\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\nclass HiddenAreasModel {\n    constructor() {\n        this.hiddenAreas = new Map();\n        this.shouldRecompute = false;\n        this.ranges = [];\n    }\n    setHiddenAreas(source, ranges) {\n        const existing = this.hiddenAreas.get(source);\n        if (existing && rangeArraysEqual(existing, ranges)) {\n            return;\n        }\n        this.hiddenAreas.set(source, ranges);\n        this.shouldRecompute = true;\n    }\n    /**\n     * The returned array is immutable.\n    */\n    getMergedRanges() {\n        if (!this.shouldRecompute) {\n            return this.ranges;\n        }\n        this.shouldRecompute = false;\n        const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n        if (rangeArraysEqual(this.ranges, newRanges)) {\n            return this.ranges;\n        }\n        this.ranges = newRanges;\n        return this.ranges;\n    }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n    const result = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        const item1 = arr1[i];\n        const item2 = arr2[j];\n        if (item1.endLineNumber < item2.startLineNumber - 1) {\n            result.push(arr1[i++]);\n        }\n        else if (item2.endLineNumber < item1.startLineNumber - 1) {\n            result.push(arr2[j++]);\n        }\n        else {\n            const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n            const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n            result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            i++;\n            j++;\n        }\n    }\n    while (i < arr1.length) {\n        result.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n        result.push(arr2[j++]);\n    }\n    return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arr1[i].equalsRange(arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n    constructor(viewportStartModelPosition, startLineDelta) {\n        this.viewportStartModelPosition = viewportStartModelPosition;\n        this.startLineDelta = startLineDelta;\n    }\n    recoverViewportStart(coordinatesConverter, viewLayout) {\n        if (!this.viewportStartModelPosition) {\n            return;\n        }\n        const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n        const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n        viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this.startLineDelta }, 1 /* ScrollType.Immediate */);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}