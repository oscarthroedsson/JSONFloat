{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AACvF,MAAM;IACT,YAAY,OAAO,EACnB;;;KAGC,GACD,KAAK,EACL;;;KAGC,GACD,UAAU,CAAE;QACR,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,UAAU,GAAG;IACtB;AACJ;AACO,MAAM;IACT,YAAY,gBAAgB,EAAE,OAAO,CAAE;QACnC,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,OAAO,GAAG;IACnB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping2(original, modified) {\n        if (isValidLineNumber(this.original.endLineNumberExclusive, original)\n            && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        if (!this.original.isEmpty && !this.modified.isEmpty) {\n            return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n            return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        // Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n        // I don't think this can happen.\n        throw new BugIndicatingError();\n    }\n}\nfunction normalizePosition(position, content) {\n    if (position.lineNumber < 1) {\n        return new Position(1, 1);\n    }\n    if (position.lineNumber > content.length) {\n        return new Position(content.length, content[content.length - 1].length + 1);\n    }\n    const line = content[position.lineNumber - 1];\n    if (position.column > line.length + 1) {\n        return new Position(position.lineNumber, line.length + 1);\n    }\n    return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n    return lineNumber >= 1 && lineNumber <= lines.length;\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    static assertSorted(rangeMappings) {\n        for (let i = 1; i < rangeMappings.length; i++) {\n            const previous = rangeMappings[i - 1];\n            const current = rangeMappings[i];\n            if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n                && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n                throw new BugIndicatingError('Range mappings must be sorted');\n            }\n        }\n    }\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA,MAAM,oCAAoC;AACnC,MAAM;IACT,YAAY,aAAa,EAAE,aAAa,EAAE,OAAO,EAAE;QAC/C,MAAM,eAAe,IAAI,aAAa,eAAe,eAAe;YAChE,oBAAoB,QAAQ,oBAAoB;YAChD,4BAA4B,QAAQ,oBAAoB;YACxD,0BAA0B;YAC1B,sBAAsB;YACtB,8BAA8B;QAClC;QACA,MAAM,SAAS,aAAa,WAAW;QACvC,MAAM,UAAU,EAAE;QAClB,IAAI,aAAa;QACjB,KAAK,MAAM,KAAK,OAAO,OAAO,CAAE;YAC5B,IAAI;YACJ,IAAI,EAAE,qBAAqB,KAAK,GAAG;gBAC/B,YAAY;gBACZ,gBAAgB,IAAI,sLAAA,CAAA,YAAS,CAAC,EAAE,uBAAuB,GAAG,GAAG,EAAE,uBAAuB,GAAG;YAC7F,OACK;gBACD,gBAAgB,IAAI,sLAAA,CAAA,YAAS,CAAC,EAAE,uBAAuB,EAAE,EAAE,qBAAqB,GAAG;YACvF;YACA,IAAI;YACJ,IAAI,EAAE,qBAAqB,KAAK,GAAG;gBAC/B,WAAW;gBACX,gBAAgB,IAAI,sLAAA,CAAA,YAAS,CAAC,EAAE,uBAAuB,GAAG,GAAG,EAAE,uBAAuB,GAAG;YAC7F,OACK;gBACD,gBAAgB,IAAI,sLAAA,CAAA,YAAS,CAAC,EAAE,uBAAuB,EAAE,EAAE,qBAAqB,GAAG;YACvF;YACA,IAAI,SAAS,IAAI,yLAAA,CAAA,2BAAwB,CAAC,eAAe,eAAe,EAAE,WAAW,EAAE,IAAI,CAAA,IAAK,IAAI,yLAAA,CAAA,eAAY,CAAC,IAAI,kLAAA,CAAA,QAAK,CAAC,EAAE,uBAAuB,EAAE,EAAE,mBAAmB,EAAE,EAAE,qBAAqB,EAAE,EAAE,iBAAiB,GAAG,IAAI,kLAAA,CAAA,QAAK,CAAC,EAAE,uBAAuB,EAAE,EAAE,mBAAmB,EAAE,EAAE,qBAAqB,EAAE,EAAE,iBAAiB;YACpU,IAAI,YAAY;gBACZ,IAAI,WAAW,QAAQ,CAAC,sBAAsB,KAAK,OAAO,QAAQ,CAAC,eAAe,IAC3E,WAAW,QAAQ,CAAC,sBAAsB,KAAK,OAAO,QAAQ,CAAC,eAAe,EAAE;oBACnF,6FAA6F;oBAC7F,SAAS,IAAI,yLAAA,CAAA,2BAAwB,CAAC,WAAW,QAAQ,CAAC,IAAI,CAAC,OAAO,QAAQ,GAAG,WAAW,QAAQ,CAAC,IAAI,CAAC,OAAO,QAAQ,GAAG,WAAW,YAAY,IAAI,OAAO,YAAY,GACtK,WAAW,YAAY,CAAC,MAAM,CAAC,OAAO,YAAY,IAAI;oBAC1D,QAAQ,GAAG;gBACf;YACJ;YACA,QAAQ,IAAI,CAAC;YACb,aAAa;QACjB;QACA,CAAA,GAAA,yKAAA,CAAA,WAAQ,AAAD,EAAE;YACL,OAAO,CAAA,GAAA,yKAAA,CAAA,qBAAkB,AAAD,EAAE,SAAS,CAAC,IAAI,KAAO,GAAG,QAAQ,CAAC,eAAe,GAAG,GAAG,QAAQ,CAAC,sBAAsB,KAAK,GAAG,QAAQ,CAAC,eAAe,GAAG,GAAG,QAAQ,CAAC,sBAAsB,IAChL,8FAA8F;gBAC9F,GAAG,QAAQ,CAAC,sBAAsB,GAAG,GAAG,QAAQ,CAAC,eAAe,IAChE,GAAG,QAAQ,CAAC,sBAAsB,GAAG,GAAG,QAAQ,CAAC,eAAe;QACxE;QACA,OAAO,IAAI,8LAAA,CAAA,YAAS,CAAC,SAAS,EAAE,EAAE,OAAO,SAAS;IACtD;AACJ;AACA,SAAS,YAAY,gBAAgB,EAAE,gBAAgB,EAAE,2BAA2B,EAAE,MAAM;IACxF,MAAM,WAAW,IAAI,+KAAA,CAAA,UAAO,CAAC,kBAAkB,kBAAkB;IACjE,OAAO,SAAS,WAAW,CAAC;AAChC;AACA,MAAM;IACF,YAAY,KAAK,CAAE;QACf,MAAM,eAAe,EAAE;QACvB,MAAM,aAAa,EAAE;QACrB,IAAK,IAAI,IAAI,GAAG,SAAS,MAAM,MAAM,EAAE,IAAI,QAAQ,IAAK;YACpD,YAAY,CAAC,EAAE,GAAG,uBAAuB,KAAK,CAAC,EAAE,EAAE;YACnD,UAAU,CAAC,EAAE,GAAG,sBAAsB,KAAK,CAAC,EAAE,EAAE;QACpD;QACA,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,cAAc;QACV,MAAM,WAAW,EAAE;QACnB,IAAK,IAAI,IAAI,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,KAAK,IAAK;YACnD,QAAQ,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,EAAE,GAAG;QAC3F;QACA,OAAO;IACX;IACA,iBAAiB,KAAK,EAAE;QACpB,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM;IAC5B;IACA,mBAAmB,CAAC,EAAE;QAClB,OAAO,IAAI;IACf;IACA,iBAAiB,CAAC,EAAE;QAChB,OAAO,IAAI;IACf;IACA,mBAAmB,0BAA0B,EAAE,UAAU,EAAE,QAAQ,EAAE;QACjE,MAAM,YAAY,EAAE;QACpB,MAAM,cAAc,EAAE;QACtB,MAAM,UAAU,EAAE;QAClB,IAAI,MAAM;QACV,IAAK,IAAI,QAAQ,YAAY,SAAS,UAAU,QAAS;YACrD,MAAM,cAAc,IAAI,CAAC,KAAK,CAAC,MAAM;YACrC,MAAM,cAAe,6BAA6B,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG;YAC9E,MAAM,YAAa,6BAA6B,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,YAAY,MAAM,GAAG;YAC/F,IAAK,IAAI,MAAM,aAAa,MAAM,WAAW,MAAO;gBAChD,SAAS,CAAC,IAAI,GAAG,YAAY,UAAU,CAAC,MAAM;gBAC9C,WAAW,CAAC,IAAI,GAAG,QAAQ;gBAC3B,OAAO,CAAC,IAAI,GAAG;gBACf;YACJ;YACA,IAAI,CAAC,8BAA8B,QAAQ,UAAU;gBACjD,2CAA2C;gBAC3C,SAAS,CAAC,IAAI,GAAG,GAAG,qBAAqB;gBACzC,WAAW,CAAC,IAAI,GAAG,QAAQ;gBAC3B,OAAO,CAAC,IAAI,GAAG,YAAY,MAAM,GAAG;gBACpC;YACJ;QACJ;QACA,OAAO,IAAI,aAAa,WAAW,aAAa;IACpD;AACJ;AACA,MAAM;IACF,YAAY,SAAS,EAAE,WAAW,EAAE,OAAO,CAAE;QACzC,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,WAAW;QACP,OAAQ,MAAM,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,MAAQ,CAAC,MAAM,GAAG,qBAAqB,MAAK,QAAQ,OAAO,YAAY,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ;IAC3L;IACA,aAAa,KAAK,EAAE,GAAG,EAAE;QACrB,IAAI,QAAQ,KAAK,SAAS,IAAI,MAAM,EAAE;YAClC,MAAM,IAAI,MAAM,CAAC,aAAa,CAAC;QACnC;IACJ;IACA,cAAc;QACV,OAAO,IAAI,CAAC,UAAU;IAC1B;IACA,mBAAmB,CAAC,EAAE;QAClB,IAAI,IAAI,KAAK,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;YACzC,8DAA8D;YAC9D,6CAA6C;YAC7C,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI;QACrC;QACA,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,YAAY;QACtC,OAAO,IAAI,CAAC,YAAY,CAAC,EAAE;IAC/B;IACA,iBAAiB,CAAC,EAAE;QAChB,IAAI,MAAM,CAAC,GAAG;YACV,8DAA8D;YAC9D,gDAAgD;YAChD,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI;QACvC;QACA,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,YAAY;QACtC,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,GAAG,qBAAqB,KAAI;YACnD,OAAO,IAAI,CAAC,YAAY,CAAC,EAAE,GAAG;QAClC;QACA,OAAO,IAAI,CAAC,YAAY,CAAC,EAAE;IAC/B;IACA,eAAe,CAAC,EAAE;QACd,IAAI,IAAI,KAAK,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YACrC,yDAAyD;YACzD,wCAAwC;YACxC,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI;QACjC;QACA,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,QAAQ;QAClC,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE;IAC3B;IACA,aAAa,CAAC,EAAE;QACZ,IAAI,MAAM,CAAC,GAAG;YACV,yDAAyD;YACzD,2CAA2C;YAC3C,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI;QACnC;QACA,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,QAAQ;QAClC,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,GAAG,qBAAqB,KAAI;YACnD,OAAO;QACX;QACA,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,GAAG;IAC9B;AACJ;AACA,MAAM;IACF,YAAY,uBAAuB,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,iBAAiB,EAAE,uBAAuB,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,iBAAiB,CAAE;QACxL,IAAI,CAAC,uBAAuB,GAAG;QAC/B,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,qBAAqB,GAAG;QAC7B,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,uBAAuB,GAAG;QAC/B,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,qBAAqB,GAAG;QAC7B,IAAI,CAAC,iBAAiB,GAAG;IAC7B;IACA,OAAO,qBAAqB,UAAU,EAAE,oBAAoB,EAAE,oBAAoB,EAAE;QAChF,MAAM,0BAA0B,qBAAqB,kBAAkB,CAAC,WAAW,aAAa;QAChG,MAAM,sBAAsB,qBAAqB,cAAc,CAAC,WAAW,aAAa;QACxF,MAAM,wBAAwB,qBAAqB,gBAAgB,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;QAC3H,MAAM,oBAAoB,qBAAqB,YAAY,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;QACnH,MAAM,0BAA0B,qBAAqB,kBAAkB,CAAC,WAAW,aAAa;QAChG,MAAM,sBAAsB,qBAAqB,cAAc,CAAC,WAAW,aAAa;QACxF,MAAM,wBAAwB,qBAAqB,gBAAgB,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;QAC3H,MAAM,oBAAoB,qBAAqB,YAAY,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;QACnH,OAAO,IAAI,WAAW,yBAAyB,qBAAqB,uBAAuB,mBAAmB,yBAAyB,qBAAqB,uBAAuB;IACvL;AACJ;AACA,SAAS,uBAAuB,UAAU;IACtC,IAAI,WAAW,MAAM,IAAI,GAAG;QACxB,OAAO;IACX;IACA,MAAM,SAAS;QAAC,UAAU,CAAC,EAAE;KAAC;IAC9B,IAAI,aAAa,MAAM,CAAC,EAAE;IAC1B,IAAK,IAAI,IAAI,GAAG,MAAM,WAAW,MAAM,EAAE,IAAI,KAAK,IAAK;QACnD,MAAM,aAAa,UAAU,CAAC,EAAE;QAChC,MAAM,yBAAyB,WAAW,aAAa,GAAG,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc;QAC/G,MAAM,yBAAyB,WAAW,aAAa,GAAG,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc;QAC/G,0GAA0G;QAC1G,MAAM,iBAAiB,KAAK,GAAG,CAAC,wBAAwB;QACxD,IAAI,iBAAiB,mCAAmC;YACpD,iDAAiD;YACjD,WAAW,cAAc,GAAG,AAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAI,WAAW,aAAa;YAC7G,WAAW,cAAc,GAAG,AAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAI,WAAW,aAAa;QACjH,OACK;YACD,yBAAyB;YACzB,OAAO,IAAI,CAAC;YACZ,aAAa;QACjB;IACJ;IACA,OAAO;AACX;AACA,MAAM;IACF,YAAY,uBAAuB,EAAE,qBAAqB,EAAE,uBAAuB,EAAE,qBAAqB,EAAE,WAAW,CAAE;QACrH,IAAI,CAAC,uBAAuB,GAAG;QAC/B,IAAI,CAAC,qBAAqB,GAAG;QAC7B,IAAI,CAAC,uBAAuB,GAAG;QAC/B,IAAI,CAAC,qBAAqB,GAAG;QAC7B,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,OAAO,qBAAqB,0BAA0B,EAAE,UAAU,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,gBAAgB,EAAE,wBAAwB,EAAE,4BAA4B,EAAE;QACtL,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI,cAAc;QAClB,IAAI,WAAW,cAAc,KAAK,GAAG;YACjC,0BAA0B,qBAAqB,kBAAkB,CAAC,WAAW,aAAa,IAAI;YAC9F,wBAAwB;QAC5B,OACK;YACD,0BAA0B,qBAAqB,kBAAkB,CAAC,WAAW,aAAa;YAC1F,wBAAwB,qBAAqB,gBAAgB,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;QACzH;QACA,IAAI,WAAW,cAAc,KAAK,GAAG;YACjC,0BAA0B,qBAAqB,kBAAkB,CAAC,WAAW,aAAa,IAAI;YAC9F,wBAAwB;QAC5B,OACK;YACD,0BAA0B,qBAAqB,kBAAkB,CAAC,WAAW,aAAa;YAC1F,wBAAwB,qBAAqB,gBAAgB,CAAC,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;QACzH;QACA,IAAI,4BAA4B,WAAW,cAAc,GAAG,KAAK,WAAW,cAAc,GAAG,MAAM,WAAW,cAAc,GAAG,KAAK,WAAW,cAAc,GAAG,MAAM,oBAAoB;YACtL,mEAAmE;YACnE,MAAM,uBAAuB,qBAAqB,kBAAkB,CAAC,4BAA4B,WAAW,aAAa,EAAE,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;YAClL,MAAM,uBAAuB,qBAAqB,kBAAkB,CAAC,4BAA4B,WAAW,aAAa,EAAE,WAAW,aAAa,GAAG,WAAW,cAAc,GAAG;YAClL,IAAI,qBAAqB,WAAW,GAAG,MAAM,GAAG,KAAK,qBAAqB,WAAW,GAAG,MAAM,GAAG,GAAG;gBAChG,IAAI,aAAa,YAAY,sBAAsB,sBAAsB,kBAAkB,MAAM,OAAO;gBACxG,IAAI,8BAA8B;oBAC9B,aAAa,uBAAuB;gBACxC;gBACA,cAAc,EAAE;gBAChB,IAAK,IAAI,IAAI,GAAG,SAAS,WAAW,MAAM,EAAE,IAAI,QAAQ,IAAK;oBACzD,YAAY,IAAI,CAAC,WAAW,oBAAoB,CAAC,UAAU,CAAC,EAAE,EAAE,sBAAsB;gBAC1F;YACJ;QACJ;QACA,OAAO,IAAI,WAAW,yBAAyB,uBAAuB,yBAAyB,uBAAuB;IAC1H;AACJ;AACO,MAAM;IACT,YAAY,aAAa,EAAE,aAAa,EAAE,IAAI,CAAE;QAC5C,IAAI,CAAC,wBAAwB,GAAG,KAAK,wBAAwB;QAC7D,IAAI,CAAC,4BAA4B,GAAG,KAAK,4BAA4B;QACrE,IAAI,CAAC,0BAA0B,GAAG,KAAK,0BAA0B;QACjE,IAAI,CAAC,oBAAoB,GAAG,KAAK,oBAAoB;QACrD,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,aAAa;QACjC,IAAI,CAAC,QAAQ,GAAG,IAAI,aAAa;QACjC,IAAI,CAAC,gBAAgB,GAAG,kCAAkC,KAAK,kBAAkB;QACjF,IAAI,CAAC,gBAAgB,GAAG,kCAAkC,KAAK,kBAAkB,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,KAAK,kBAAkB,EAAE,QAAQ,8CAA8C;IAC1L;IACA,cAAc;QACV,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,KAAK,GAAG;YACzE,8BAA8B;YAC9B,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,KAAK,GAAG;gBACzE,OAAO;oBACH,WAAW;oBACX,SAAS,EAAE;gBACf;YACJ;YACA,OAAO;gBACH,WAAW;gBACX,SAAS;oBAAC;wBACF,yBAAyB;wBACzB,uBAAuB;wBACvB,yBAAyB;wBACzB,uBAAuB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM;wBACjD,aAAa;oBACjB;iBAAE;YACV;QACJ;QACA,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,KAAK,GAAG;YACzE,8BAA8B;YAC9B,OAAO;gBACH,WAAW;gBACX,SAAS;oBAAC;wBACF,yBAAyB;wBACzB,uBAAuB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM;wBACjD,yBAAyB;wBACzB,uBAAuB;wBACvB,aAAa;oBACjB;iBAAE;YACV;QACJ;QACA,MAAM,aAAa,YAAY,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,oBAAoB;QAC7G,MAAM,aAAa,WAAW,OAAO;QACrC,MAAM,YAAY,WAAW,SAAS;QACtC,4DAA4D;QAC5D,yCAAyC;QACzC,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,MAAM,cAAc,EAAE;YACtB,IAAK,IAAI,IAAI,GAAG,SAAS,WAAW,MAAM,EAAE,IAAI,QAAQ,IAAK;gBACzD,YAAY,IAAI,CAAC,WAAW,oBAAoB,CAAC,IAAI,CAAC,0BAA0B,EAAE,UAAU,CAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,wBAAwB,EAAE,IAAI,CAAC,4BAA4B;YAC1N;YACA,OAAO;gBACH,WAAW;gBACX,SAAS;YACb;QACJ;QACA,oFAAoF;QACpF,0FAA0F;QAC1F,MAAM,SAAS,EAAE;QACjB,IAAI,oBAAoB;QACxB,IAAI,oBAAoB;QACxB,IAAK,IAAI,IAAI,CAAC,EAAE,QAAQ,KAAI,MAAM,WAAW,MAAM,EAAE,IAAI,KAAK,IAAK;YAC/D,MAAM,aAAc,IAAI,IAAI,MAAM,UAAU,CAAC,IAAI,EAAE,GAAG;YACtD,MAAM,eAAgB,aAAa,WAAW,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM;YACvF,MAAM,eAAgB,aAAa,WAAW,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM;YACvF,MAAO,oBAAoB,gBAAgB,oBAAoB,aAAc;gBACzE,MAAM,eAAe,IAAI,CAAC,aAAa,CAAC,kBAAkB;gBAC1D,MAAM,eAAe,IAAI,CAAC,aAAa,CAAC,kBAAkB;gBAC1D,IAAI,iBAAiB,cAAc;oBAC/B,6CAA6C;oBAC7C,+BAA+B;oBAC/B;wBACI,IAAI,sBAAsB,uBAAuB,cAAc;wBAC/D,IAAI,sBAAsB,uBAAuB,cAAc;wBAC/D,MAAO,sBAAsB,KAAK,sBAAsB,EAAG;4BACvD,MAAM,eAAe,aAAa,UAAU,CAAC,sBAAsB;4BACnE,MAAM,eAAe,aAAa,UAAU,CAAC,sBAAsB;4BACnE,IAAI,iBAAiB,cAAc;gCAC/B;4BACJ;4BACA;4BACA;wBACJ;wBACA,IAAI,sBAAsB,KAAK,sBAAsB,GAAG;4BACpD,IAAI,CAAC,6BAA6B,CAAC,QAAQ,oBAAoB,GAAG,GAAG,qBAAqB,oBAAoB,GAAG,GAAG;wBACxH;oBACJ;oBACA,gCAAgC;oBAChC;wBACI,IAAI,oBAAoB,sBAAsB,cAAc;wBAC5D,IAAI,oBAAoB,sBAAsB,cAAc;wBAC5D,MAAM,oBAAoB,aAAa,MAAM,GAAG;wBAChD,MAAM,oBAAoB,aAAa,MAAM,GAAG;wBAChD,MAAO,oBAAoB,qBAAqB,oBAAoB,kBAAmB;4BACnF,MAAM,eAAe,aAAa,UAAU,CAAC,oBAAoB;4BACjE,MAAM,eAAe,aAAa,UAAU,CAAC,oBAAoB;4BACjE,IAAI,iBAAiB,cAAc;gCAC/B;4BACJ;4BACA;4BACA;wBACJ;wBACA,IAAI,oBAAoB,qBAAqB,oBAAoB,mBAAmB;4BAChF,IAAI,CAAC,6BAA6B,CAAC,QAAQ,oBAAoB,GAAG,mBAAmB,mBAAmB,oBAAoB,GAAG,mBAAmB;wBACtJ;oBACJ;gBACJ;gBACA;gBACA;YACJ;YACA,IAAI,YAAY;gBACZ,yBAAyB;gBACzB,OAAO,IAAI,CAAC,WAAW,oBAAoB,CAAC,IAAI,CAAC,0BAA0B,EAAE,YAAY,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,wBAAwB,EAAE,IAAI,CAAC,4BAA4B;gBAC9M,qBAAqB,WAAW,cAAc;gBAC9C,qBAAqB,WAAW,cAAc;YAClD;QACJ;QACA,OAAO;YACH,WAAW;YACX,SAAS;QACb;IACJ;IACA,8BAA8B,MAAM,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE;QAC1J,IAAI,IAAI,CAAC,8BAA8B,CAAC,QAAQ,oBAAoB,qBAAqB,mBAAmB,oBAAoB,qBAAqB,oBAAoB;YACrK,uBAAuB;YACvB;QACJ;QACA,IAAI,cAAc;QAClB,IAAI,IAAI,CAAC,wBAAwB,EAAE;YAC/B,cAAc;gBAAC,IAAI,WAAW,oBAAoB,qBAAqB,oBAAoB,mBAAmB,oBAAoB,qBAAqB,oBAAoB;aAAmB;QAClM;QACA,OAAO,IAAI,CAAC,IAAI,WAAW,oBAAoB,oBAAoB,oBAAoB,oBAAoB;IAC/G;IACA,+BAA+B,MAAM,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE;QAC3J,MAAM,MAAM,OAAO,MAAM;QACzB,IAAI,QAAQ,GAAG;YACX,OAAO;QACX;QACA,MAAM,aAAa,MAAM,CAAC,MAAM,EAAE;QAClC,IAAI,WAAW,qBAAqB,KAAK,KAAK,WAAW,qBAAqB,KAAK,GAAG;YAClF,mCAAmC;YACnC,OAAO;QACX;QACA,IAAI,WAAW,qBAAqB,KAAK,sBAAsB,WAAW,qBAAqB,KAAK,oBAAoB;YACpH,IAAI,IAAI,CAAC,wBAAwB,IAAI,WAAW,WAAW,EAAE;gBACzD,WAAW,WAAW,CAAC,IAAI,CAAC,IAAI,WAAW,oBAAoB,qBAAqB,oBAAoB,mBAAmB,oBAAoB,qBAAqB,oBAAoB;YAC5L;YACA,OAAO;QACX;QACA,IAAI,WAAW,qBAAqB,GAAG,MAAM,sBAAsB,WAAW,qBAAqB,GAAG,MAAM,oBAAoB;YAC5H,WAAW,qBAAqB,GAAG;YACnC,WAAW,qBAAqB,GAAG;YACnC,IAAI,IAAI,CAAC,wBAAwB,IAAI,WAAW,WAAW,EAAE;gBACzD,WAAW,WAAW,CAAC,IAAI,CAAC,IAAI,WAAW,oBAAoB,qBAAqB,oBAAoB,mBAAmB,oBAAoB,qBAAqB,oBAAoB;YAC5L;YACA,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACA,SAAS,uBAAuB,GAAG,EAAE,YAAY;IAC7C,MAAM,IAAI,CAAA,GAAA,0KAAA,CAAA,0BAA+B,AAAD,EAAE;IAC1C,IAAI,MAAM,CAAC,GAAG;QACV,OAAO;IACX;IACA,OAAO,IAAI;AACf;AACA,SAAS,sBAAsB,GAAG,EAAE,YAAY;IAC5C,MAAM,IAAI,CAAA,GAAA,0KAAA,CAAA,yBAA8B,AAAD,EAAE;IACzC,IAAI,MAAM,CAAC,GAAG;QACV,OAAO;IACX;IACA,OAAO,IAAI;AACf;AACA,SAAS,kCAAkC,cAAc;IACrD,IAAI,mBAAmB,GAAG;QACtB,OAAO,IAAM;IACjB;IACA,MAAM,YAAY,KAAK,GAAG;IAC1B,OAAO;QACH,OAAO,KAAK,GAAG,KAAK,YAAY;IACpC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 689, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    static assertSorted(sequenceDiffs) {\n        let last = undefined;\n        for (const cur of sequenceDiffs) {\n            if (last) {\n                if (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n                    throw new BugIndicatingError('Sequence diffs must be sorted');\n                }\n            }\n            last = cur;\n        }\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nexport class OffsetPair {\n    static { this.zero = new OffsetPair(0, 0); }\n    static { this.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER); }\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n    }\n    equals(other) {\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n    }\n}\nexport class InfiniteTimeout {\n    static { this.instance = new InfiniteTimeout(); }\n    isValid() {\n        return true;\n    }\n}\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 850, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nexport function isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nexport class LineRangeFragment {\n    static { this.chrKeys = new Map(); }\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;AACvF,MAAM;IACT,YAAY,KAAK,EAAE,MAAM,CAAE;QACvB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,KAAK,GAAG,EAAE;QACf,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM,QAAQ;IACnC;IACA,IAAI,CAAC,EAAE,CAAC,EAAE;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC;IACzC;IACA,IAAI,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE;QACb,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;IACrC;AACJ;AACO,SAAS,QAAQ,QAAQ;IAC5B,OAAO,aAAa,GAAG,kBAAkB,OAAM,aAAa,EAAE,gBAAgB;AAClF;AACO,MAAM;IACT,MAAO;QAAE,IAAI,CAAC,OAAO,GAAG,IAAI;IAAO,CAAC;IACpC,OAAO,OAAO,GAAG,EAAE;QACf,IAAI,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;QAC3B,IAAI,QAAQ,WAAW;YACnB,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI;YACvB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK;QAC1B;QACA,OAAO;IACX;IACA,YAAY,KAAK,EAAE,KAAK,EAAE,MAAM,CAAE;QAC9B,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG,EAAE;QACnB,IAAI,UAAU;QACd,IAAK,IAAI,IAAI,MAAM,eAAe,GAAG,GAAG,IAAI,MAAM,sBAAsB,GAAG,GAAG,IAAK;YAC/E,MAAM,OAAO,KAAK,CAAC,EAAE;YACrB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;gBAClC;gBACA,MAAM,MAAM,IAAI,CAAC,EAAE;gBACnB,MAAM,MAAM,kBAAkB,MAAM,CAAC;gBACrC,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,IAAI;YACvD;YACA;YACA,MAAM,MAAM,kBAAkB,MAAM,CAAC;YACrC,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,IAAI;QACvD;QACA,IAAI,CAAC,UAAU,GAAG;IACtB;IACA,kBAAkB,KAAK,EAAE;QACrB,IAAI,iBAAiB;QACrB,MAAM,YAAY,KAAK,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,SAAS,CAAC,MAAM;QACxE,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;YAChC,kBAAkB,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,SAAS,CAAC,EAAE,IAAI,CAAC;QAClF;QACA,OAAO,IAAK,iBAAiB,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,UAAU;IACpE;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 922, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;AACA;;;;AAKO,MAAM;IACT,QAAQ,SAAS,EAAE,SAAS,EAAE,UAAU,oOAAA,CAAA,kBAAe,CAAC,QAAQ,EAAE,aAAa,EAAE;QAC7E,IAAI,UAAU,MAAM,KAAK,KAAK,UAAU,MAAM,KAAK,GAAG;YAClD,OAAO,oOAAA,CAAA,sBAAmB,CAAC,OAAO,CAAC,WAAW;QAClD;QACA;;SAEC,GACD,MAAM,aAAa,IAAI,8MAAA,CAAA,UAAO,CAAC,UAAU,MAAM,EAAE,UAAU,MAAM;QACjE,MAAM,aAAa,IAAI,8MAAA,CAAA,UAAO,CAAC,UAAU,MAAM,EAAE,UAAU,MAAM;QACjE,MAAM,UAAU,IAAI,8MAAA,CAAA,UAAO,CAAC,UAAU,MAAM,EAAE,UAAU,MAAM;QAC9D,oCAAoC;QACpC,IAAK,IAAI,KAAK,GAAG,KAAK,UAAU,MAAM,EAAE,KAAM;YAC1C,IAAK,IAAI,KAAK,GAAG,KAAK,UAAU,MAAM,EAAE,KAAM;gBAC1C,IAAI,CAAC,QAAQ,OAAO,IAAI;oBACpB,OAAO,oOAAA,CAAA,sBAAmB,CAAC,eAAe,CAAC,WAAW;gBAC1D;gBACA,MAAM,gBAAgB,OAAO,IAAI,IAAI,WAAW,GAAG,CAAC,KAAK,GAAG;gBAC5D,MAAM,cAAc,OAAO,IAAI,IAAI,WAAW,GAAG,CAAC,IAAI,KAAK;gBAC3D,IAAI;gBACJ,IAAI,UAAU,UAAU,CAAC,QAAQ,UAAU,UAAU,CAAC,KAAK;oBACvD,IAAI,OAAO,KAAK,OAAO,GAAG;wBACtB,mBAAmB;oBACvB,OACK;wBACD,mBAAmB,WAAW,GAAG,CAAC,KAAK,GAAG,KAAK;oBACnD;oBACA,IAAI,KAAK,KAAK,KAAK,KAAK,WAAW,GAAG,CAAC,KAAK,GAAG,KAAK,OAAO,GAAG;wBAC1D,+BAA+B;wBAC/B,oBAAoB,QAAQ,GAAG,CAAC,KAAK,GAAG,KAAK;oBACjD;oBACA,oBAAqB,gBAAgB,cAAc,IAAI,MAAM;gBACjE,OACK;oBACD,mBAAmB,CAAC;gBACxB;gBACA,MAAM,WAAW,KAAK,GAAG,CAAC,eAAe,aAAa;gBACtD,IAAI,aAAa,kBAAkB;oBAC/B,mBAAmB;oBACnB,MAAM,UAAU,KAAK,KAAK,KAAK,IAAI,QAAQ,GAAG,CAAC,KAAK,GAAG,KAAK,KAAK;oBACjE,QAAQ,GAAG,CAAC,IAAI,IAAI,UAAU;oBAC9B,WAAW,GAAG,CAAC,IAAI,IAAI;gBAC3B,OACK,IAAI,aAAa,eAAe;oBACjC,QAAQ,GAAG,CAAC,IAAI,IAAI;oBACpB,WAAW,GAAG,CAAC,IAAI,IAAI;gBAC3B,OACK,IAAI,aAAa,aAAa;oBAC/B,QAAQ,GAAG,CAAC,IAAI,IAAI;oBACpB,WAAW,GAAG,CAAC,IAAI,IAAI;gBAC3B;gBACA,WAAW,GAAG,CAAC,IAAI,IAAI;YAC3B;QACJ;QACA,yBAAyB;QACzB,MAAM,SAAS,EAAE;QACjB,IAAI,oBAAoB,UAAU,MAAM;QACxC,IAAI,oBAAoB,UAAU,MAAM;QACxC,SAAS,kCAAkC,EAAE,EAAE,EAAE;YAC7C,IAAI,KAAK,MAAM,qBAAqB,KAAK,MAAM,mBAAmB;gBAC9D,OAAO,IAAI,CAAC,IAAI,oOAAA,CAAA,eAAY,CAAC,IAAI,wLAAA,CAAA,cAAW,CAAC,KAAK,GAAG,oBAAoB,IAAI,wLAAA,CAAA,cAAW,CAAC,KAAK,GAAG;YACrG;YACA,oBAAoB;YACpB,oBAAoB;QACxB;QACA,IAAI,KAAK,UAAU,MAAM,GAAG;QAC5B,IAAI,KAAK,UAAU,MAAM,GAAG;QAC5B,MAAO,MAAM,KAAK,MAAM,EAAG;YACvB,IAAI,WAAW,GAAG,CAAC,IAAI,QAAQ,GAAG;gBAC9B,kCAAkC,IAAI;gBACtC;gBACA;YACJ,OACK;gBACD,IAAI,WAAW,GAAG,CAAC,IAAI,QAAQ,GAAG;oBAC9B;gBACJ,OACK;oBACD;gBACJ;YACJ;QACJ;QACA,kCAAkC,CAAC,GAAG,CAAC;QACvC,OAAO,OAAO;QACd,OAAO,IAAI,oOAAA,CAAA,sBAAmB,CAAC,QAAQ;IAC3C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1020, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1178, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, range, considerWhitespaceChanges) {\n        this.lines = lines;\n        this.range = range;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstElementOffsetByLineIdx = [];\n        this.lineStartOffsets = [];\n        this.trimmedWsLengthsByLineIdx = [];\n        this.firstElementOffsetByLineIdx.push(0);\n        for (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n            let line = lines[lineNumber - 1];\n            let lineStartOffset = 0;\n            if (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n                lineStartOffset = this.range.startColumn - 1;\n                line = line.substring(lineStartOffset);\n            }\n            this.lineStartOffsets.push(lineStartOffset);\n            let trimmedWsLength = 0;\n            if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                trimmedWsLength = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n            const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n            for (let i = 0; i < lineLength; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            if (lineNumber < this.range.endLineNumber) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstElementOffsetByLineIdx.push(this.elements.length);\n            }\n        }\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // prefer the linebreak before the change\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset, preference = 'right') {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        const i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n        const lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n        return new Position(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i]));\n    }\n    translateRange(range) {\n        const pos1 = this.translateOffset(range.start, 'right');\n        const pos2 = this.translateOffset(range.endExclusive, 'left');\n        if (pos2.isBefore(pos1)) {\n            return Range.fromPositions(pos2, pos2);\n        }\n        return Range.fromPositions(pos1, pos2);\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        const start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n        const end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 30,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1359, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false), new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1631, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = new OffsetPair(0, 0);\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = new SequenceDiff(w1, w2);\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        // The words do not touch previous equals mappings, as we would have processed them already.\n        // But they might touch the next ones.\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            // Because there is an intersection, we know that the words are not empty.\n            const v = new SequenceDiff(v1, v2);\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                // The word extends beyond the next equal mapping.\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2000, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AACvF,MAAM;IACT,YAAY,WAAW,EAAE,KAAK,CAAE;QAC5B,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,KAAK,GAAG;IACjB;IACA,WAAW,MAAM,EAAE;QACf,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO;IACnC;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM;IAClC;IACA,iBAAiB,MAAM,EAAE;QACrB,MAAM,oBAAoB,WAAW,IAAI,IAAI,eAAe,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;QAClF,MAAM,mBAAmB,WAAW,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,eAAe,IAAI,CAAC,KAAK,CAAC,OAAO;QAC7F,OAAO,OAAO,CAAC,oBAAoB,gBAAgB;IACvD;IACA,QAAQ,KAAK,EAAE;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,KAAK,EAAE,MAAM,YAAY,EAAE,IAAI,CAAC;IAClE;IACA,gBAAgB,OAAO,EAAE,OAAO,EAAE;QAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ;IACtD;AACJ;AACA,SAAS,eAAe,GAAG;IACvB,IAAI,IAAI;IACR,MAAO,IAAI,IAAI,MAAM,IAAI,CAAC,IAAI,UAAU,CAAC,OAAO,GAAG,kBAAkB,OAAM,IAAI,UAAU,CAAC,OAAO,EAAE,gBAAgB,GAAE,EAAG;QACpH;IACJ;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2042, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../rangeMapping.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const lineRangeMapping = toLineRangeMapping(diff);\n        const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n        const slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        const check = false;\n        let diffs = diffResult.diffs;\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        if (check) {\n            RangeMapping.assertSorted(result);\n        }\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction toLineRangeMapping(sequenceDiff) {\n    return new LineRangeMapping(new LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1), new LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2300, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;;;AACO,MAAM,qBAAqB;IAC9B,WAAW,IAAM,IAAI,oMAAA,CAAA,0BAAuB;IAC5C,YAAY,IAAM,IAAI,iOAAA,CAAA,2BAAwB;AAClD","ignoreList":[0],"debugId":null}}]
}