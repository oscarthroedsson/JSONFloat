{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 556, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && lastCutRange?.endLineNumber !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 785, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _createIntlWord(intlWord, nextCharClass) {\n        // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n        return { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: 1 /* WordType.Regular */, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return this._createIntlWord(previousIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index) {\n                return this._createIntlWord(nextIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType, hasMulticursor) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n                && prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position, hasMulticursor) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */, hasMulticursor),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */, hasMulticursor),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1482, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.metadata = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;AAC9F;AACA;AACA;AACA;AACA;AACA;;;;;;;AACO,MAAM;IACT,OAAO,cAAc,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE;QACrD,MAAM,SAAS,EAAE;QACjB,IAAI,YAAY;QAChB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,YAAY,GAAG,IAAI,iLAAA,CAAA,cAAW,CAAC,OAAO,UAAU,EAAE,OAAO,SAAS;YACzE,IAAI,gBAAgB;gBAChB,MAAM,CAAC,YAAY,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,aAAa,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU;YAC5I,OACK;gBACD,MAAM,CAAC,YAAY,GAAG,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,aAAa,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS;YACpI;QACJ;QACA,OAAO;IACX;IACA,OAAO,YAAY,SAAS,EAAE,OAAO,EAAE,cAAc,EAAE;QACnD,MAAM,SAAS,EAAE;QACjB,IAAI,YAAY;QAChB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,YAAY,GAAG,IAAI,iLAAA,CAAA,cAAW,CAAC,OAAO,UAAU,EAAE,OAAO,SAAS;YACzE,IAAI,gBAAgB;gBAChB,MAAM,CAAC,YAAY,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,WAAW,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU;YAC1I,OACK;gBACD,MAAM,CAAC,YAAY,GAAG,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,WAAW,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS;YAClI;QACJ;QACA,OAAO;IACX;IACA,OAAO,sBAAsB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC9D,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,gBAAgB,CAAC,WAAW,QAAQ;QACzD;QACA,OAAO;IACX;IACA,OAAO,iBAAiB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE;QACxD,MAAM,yBAAyB,OAAO,SAAS,CAAC,QAAQ,CAAC,MAAM;QAC/D,MAAM,0BAA0B,OAAO,UAAU,CAAC,QAAQ,CAAC,MAAM;QACjE,MAAM,2BAA2B,2BAA2B;QAC5D,MAAM,6BAA6B,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;QACvE,MAAM,sBAAsB,UAAU,+BAA+B,CAAC;QACtE,MAAM,wBAAwB,2BAA2B;QACzD,IAAI,CAAC,4BAA4B,CAAC,uBAAuB;YACrD,OAAO,IAAI,CAAC,sBAAsB,CAAC,WAAW,QAAQ;QAC1D,OACK;YACD,OAAO,IAAI,CAAC,uBAAuB,CAAC,WAAW,QAAQ;QAC3D;IACJ;IACA,OAAO,uBAAuB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE;QAC9D,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,qBAAqB,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE;IAC/H;IACA,OAAO,wBAAwB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE;QAC/D,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,qBAAqB,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE;IACvI;IACA,OAAO,gBAAgB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,MAAM,EAAE;QAChE,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,QAAQ,iBAAiB;QACxE;QACA,OAAO;IACX;IACA,OAAO,eAAe,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE;QAC9D,MAAM,oBAAoB,OAAO,SAAS,CAAC,QAAQ;QACnD,MAAM,qBAAqB,UAAU,gBAAgB,CAAC,kBAAkB,UAAU;QAClF,MAAM,kBAAkB,kBAAkB,MAAM,KAAK;QACrD,MAAM,qBAAqB,OAAO,UAAU,CAAC,QAAQ;QACrD,MAAM,iBAAiB,UAAU,KAAK,CAAC,gBAAgB,CAAC,mBAAmB,UAAU;QACrF,MAAM,yBAAyB,qBAAqB,kBAAkB,MAAM,KAAK,iBAAiB,mBAAmB,MAAM;QAC3H,IAAI,mBAAmB,wBAAwB;YAC3C,OAAO,IAAI,CAAC,qBAAqB,CAAC,WAAW,QAAQ,iBAAiB;QAC1E,OACK;YACD,OAAO,IAAI,CAAC,oBAAoB,CAAC,WAAW,QAAQ,iBAAiB;QACzE;IACJ;IACA,OAAO,qBAAqB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE;QACpE,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,eAAe,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;IAC1I;IACA,OAAO,sBAAsB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE;QACrE,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,eAAe,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE,iBAAiB;IAClJ;IACA,OAAO,oBAAoB,SAAS,EAAE,OAAO,EAAE;QAC3C,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,kBAAkB,OAAO,UAAU,CAAC,SAAS,CAAC,eAAe;YACnE,MAAM,YAAY,UAAU,KAAK,CAAC,YAAY;YAC9C,IAAI,gBAAgB,OAAO,UAAU,CAAC,SAAS,CAAC,aAAa;YAC7D,IAAI;YACJ,IAAI,kBAAkB,WAAW;gBAC7B,YAAY,UAAU,KAAK,CAAC,gBAAgB,CAAC;YACjD,OACK;gBACD;gBACA,YAAY;YAChB;YACA,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,IAAI,iLAAA,CAAA,oBAAiB,CAAC,IAAI,kLAAA,CAAA,QAAK,CAAC,iBAAiB,GAAG,iBAAiB,IAAI,EAAE,6BAA6B,KAAI,GAAG,IAAI,qLAAA,CAAA,WAAQ,CAAC,eAAe,YAAY;QAClM;QACA,OAAO;IACX;IACA,OAAO,wBAAwB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAChE,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,uBAAuB,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE;QAC9I;QACA,OAAO;IACX;IACA,OAAO,kBAAkB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC1D,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,iBAAiB,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE;QACxI;QACA,OAAO;IACX;IACA,OAAO,UAAU,SAAS,EAAE,MAAM,EAAE;QAChC,MAAM,YAAY,UAAU,KAAK,CAAC,YAAY;QAC9C,MAAM,YAAY,UAAU,KAAK,CAAC,gBAAgB,CAAC;QACnD,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,IAAI,iLAAA,CAAA,oBAAiB,CAAC,IAAI,kLAAA,CAAA,QAAK,CAAC,GAAG,GAAG,GAAG,IAAI,EAAE,6BAA6B,KAAI,GAAG,IAAI,qLAAA,CAAA,WAAQ,CAAC,WAAW,YAAY;IAC7J;IACA,OAAO,KAAK,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,SAAS,EAAE,aAAa,EAAE;QACtE,MAAM,WAAW,UAAU,KAAK,CAAC,gBAAgB,CAAC;QAClD,MAAM,eAAgB,gBAChB,UAAU,oBAAoB,CAAC,oBAAoB,CAAC,IAAI,qLAAA,CAAA,WAAQ,CAAC,cAAc,UAAU,EAAE,cAAc,MAAM,GAAG,YAClH,UAAU,oBAAoB,CAAC,kCAAkC,CAAC;QACxE,IAAI,CAAC,iBAAiB;YAClB,6CAA6C;YAC7C,MAAM,YAAY,UAAU,KAAK,CAAC,YAAY;YAC9C,IAAI,qBAAqB,SAAS,UAAU,GAAG;YAC/C,IAAI,iBAAiB;YACrB,IAAI,qBAAqB,WAAW;gBAChC,qBAAqB;gBACrB,iBAAiB,UAAU,KAAK,CAAC,gBAAgB,CAAC;YACtD;YACA,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,IAAI,iLAAA,CAAA,oBAAiB,CAAC,IAAI,kLAAA,CAAA,QAAK,CAAC,SAAS,UAAU,EAAE,GAAG,oBAAoB,iBAAiB,EAAE,2BAA2B,KAAI,GAAG,IAAI,qLAAA,CAAA,WAAQ,CAAC,oBAAoB,iBAAiB;QACzN;QACA,4BAA4B;QAC5B,MAAM,qBAAqB,OAAO,UAAU,CAAC,cAAc,CAAC,gBAAgB,GAAG,UAAU;QACzF,IAAI,SAAS,UAAU,GAAG,oBAAoB;YAC1C,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,OAAO,SAAS,CAAC,IAAI,CAAC,MAAM,aAAa,UAAU,EAAE,GAAG;QAC7F,OACK,IAAI,SAAS,UAAU,GAAG,oBAAoB;YAC/C,MAAM,YAAY,UAAU,YAAY;YACxC,IAAI,yBAAyB,aAAa,UAAU,GAAG;YACvD,IAAI,qBAAqB;YACzB,IAAI,yBAAyB,WAAW;gBACpC,yBAAyB;gBACzB,qBAAqB,UAAU,gBAAgB,CAAC;YACpD;YACA,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,OAAO,SAAS,CAAC,IAAI,CAAC,MAAM,wBAAwB,oBAAoB;QAC7G,OACK;YACD,MAAM,8BAA8B,OAAO,UAAU,CAAC,cAAc,CAAC,cAAc;YACnF,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,OAAO,UAAU,CAAC,IAAI,CAAC,MAAM,4BAA4B,UAAU,EAAE,4BAA4B,MAAM,EAAE;QAC/I;IACJ;IACA,OAAO,KAAK,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,SAAS,EAAE;QACvD,MAAM,WAAW,UAAU,KAAK,CAAC,gBAAgB,CAAC;QAClD,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,IAAI,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE,iBAAiB;IACvI;IACA,OAAO,gBAAgB,SAAS,EAAE,MAAM,EAAE;QACtC,IAAI,CAAC,OAAO,UAAU,CAAC,YAAY,IAAI;YACnC,OAAO,IAAI,iLAAA,CAAA,cAAW,CAAC,OAAO,UAAU,EAAE,OAAO,SAAS;QAC9D;QACA,MAAM,aAAa,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;QACvD,MAAM,SAAS,OAAO,SAAS,CAAC,QAAQ,CAAC,MAAM;QAC/C,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,IAAI,iLAAA,CAAA,oBAAiB,CAAC,IAAI,kLAAA,CAAA,QAAK,CAAC,YAAY,QAAQ,YAAY,SAAS,EAAE,6BAA6B,KAAI,GAAG,IAAI,qLAAA,CAAA,WAAQ,CAAC,YAAY,SAAS;IACtL;IACA,OAAO,OAAO,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,SAAS,EAAE,aAAa,EAAE;QACxE,IAAI,iBAAiB;YACjB,IAAI,OAAO,UAAU,CAAC,kBAAkB,KAAK,EAAE,2BAA2B,KAAI;gBAC1E,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,QAAQ,iBAAiB;YACzD;YACA,IAAI,OAAO,UAAU,CAAC,kBAAkB,KAAK,EAAE,2BAA2B,KAAI;gBAC1E,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,QAAQ,iBAAiB,WAAW;YACpE;QACJ;QACA,MAAM,WAAW,UAAU,KAAK,CAAC,gBAAgB,CAAC;QAClD,MAAM,eAAgB,gBAChB,UAAU,oBAAoB,CAAC,oBAAoB,CAAC,IAAI,qLAAA,CAAA,WAAQ,CAAC,cAAc,UAAU,EAAE,cAAc,MAAM,GAAG,YAClH,UAAU,oBAAoB,CAAC,kCAAkC,CAAC;QACxE,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,OAAO,SAAS,CAAC,IAAI,CAAC,iBAAiB,aAAa,UAAU,EAAE,aAAa,MAAM,EAAE;IAC1H;IACA,OAAO,WAAW,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,eAAe,EAAE,KAAK,EAAE,IAAI,EAAE;QAC3E,OAAQ;YACJ,KAAK,EAAE,6BAA6B;gBAAI;oBACpC,IAAI,SAAS,EAAE,4BAA4B,KAAI;wBAC3C,4CAA4C;wBAC5C,OAAO,IAAI,CAAC,iBAAiB,CAAC,WAAW,SAAS;oBACtD,OACK;wBACD,0CAA0C;wBAC1C,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,SAAS,iBAAiB;oBAC/D;gBACJ;YACA,KAAK,EAAE,8BAA8B;gBAAI;oBACrC,IAAI,SAAS,EAAE,4BAA4B,KAAI;wBAC3C,6CAA6C;wBAC7C,OAAO,IAAI,CAAC,kBAAkB,CAAC,WAAW,SAAS;oBACvD,OACK;wBACD,2CAA2C;wBAC3C,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,SAAS,iBAAiB;oBAChE;gBACJ;YACA,KAAK,EAAE,2BAA2B;gBAAI;oBAClC,IAAI,SAAS,EAAE,+BAA+B,KAAI;wBAC9C,wBAAwB;wBACxB,OAAO,IAAI,CAAC,kBAAkB,CAAC,WAAW,SAAS,iBAAiB;oBACxE,OACK;wBACD,yBAAyB;wBACzB,OAAO,IAAI,CAAC,mBAAmB,CAAC,WAAW,SAAS,iBAAiB;oBACzE;gBACJ;YACA,KAAK,EAAE,6BAA6B;gBAAI;oBACpC,IAAI,SAAS,EAAE,+BAA+B,KAAI;wBAC9C,0BAA0B;wBAC1B,OAAO,IAAI,CAAC,oBAAoB,CAAC,WAAW,SAAS,iBAAiB;oBAC1E,OACK;wBACD,2BAA2B;wBAC3B,OAAO,IAAI,CAAC,qBAAqB,CAAC,WAAW,SAAS,iBAAiB;oBAC3E;gBACJ;YACA,KAAK,EAAE,sCAAsC;gBAAI;oBAC7C,IAAI,SAAS,EAAE,+BAA+B,KAAI;wBAC9C,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,mBAAmB,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE;oBACnJ,OACK;wBACD,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,mBAAmB,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE;oBAC3J;gBACJ;YACA,KAAK,EAAE,sCAAsC;gBAAI;oBAC7C,IAAI,SAAS,EAAE,+BAA+B,KAAI;wBAC9C,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,mBAAmB,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE;oBACnJ,OACK;wBACD,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,mBAAmB,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE;oBAC3J;gBACJ;YACA,KAAK,EAAE,yCAAyC;gBAAI;oBAChD,iDAAiD;oBACjD,OAAO,IAAI,CAAC,oBAAoB,CAAC,WAAW,SAAS;gBACzD;YACA,KAAK,EAAE,+DAA+D;gBAAI;oBACtE,mEAAmE;oBACnE,OAAO,IAAI,CAAC,mCAAmC,CAAC,WAAW,SAAS;gBACxE;YACA,KAAK,EAAE,gDAAgD;gBAAI;oBACvD,gDAAgD;oBAChD,OAAO,IAAI,CAAC,uBAAuB,CAAC,WAAW,SAAS;gBAC5D;YACA,KAAK,EAAE,uCAAuC;gBAAI;oBAC9C,2CAA2C;oBAC3C,OAAO,IAAI,CAAC,oBAAoB,CAAC,WAAW,SAAS;gBACzD;YACA,KAAK,GAAG,8DAA8D;gBAAI;oBACtE,kEAAkE;oBAClE,OAAO,IAAI,CAAC,kCAAkC,CAAC,WAAW,SAAS;gBACvE;YACA;gBACI,OAAO;QACf;IACJ;IACA,OAAO,aAAa,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,eAAe,EAAE,KAAK,EAAE;QACvE,MAAM,mBAAmB,UAAU,6BAA6B;QAChE,MAAM,oBAAoB,UAAU,oBAAoB,CAAC,4BAA4B,CAAC;QACtF,OAAQ;YACJ,KAAK,GAAG,oCAAoC;gBAAI;oBAC5C,4DAA4D;oBAC5D,MAAM,kBAAkB,IAAI,CAAC,uBAAuB,CAAC,UAAU,KAAK,EAAE,mBAAmB;oBACzF,MAAM,cAAc,UAAU,KAAK,CAAC,+BAA+B,CAAC;oBACpE,OAAO;wBAAC,IAAI,CAAC,oBAAoB,CAAC,WAAW,OAAO,CAAC,EAAE,EAAE,iBAAiB,iBAAiB;qBAAa;gBAC5G;YACA,KAAK,GAAG,uCAAuC;gBAAI;oBAC/C,+DAA+D;oBAC/D,MAAM,kBAAkB,IAAI,CAAC,sBAAsB,CAAC,UAAU,KAAK,EAAE,mBAAmB;oBACxF,MAAM,cAAc,UAAU,KAAK,CAAC,+BAA+B,CAAC;oBACpE,OAAO;wBAAC,IAAI,CAAC,oBAAoB,CAAC,WAAW,OAAO,CAAC,EAAE,EAAE,iBAAiB,iBAAiB;qBAAa;gBAC5G;YACA,KAAK,GAAG,uCAAuC;gBAAI;oBAC/C,gDAAgD;oBAChD,MAAM,kBAAkB,KAAK,KAAK,CAAC,CAAC,kBAAkB,eAAe,GAAG,kBAAkB,aAAa,IAAI;oBAC3G,MAAM,cAAc,UAAU,KAAK,CAAC,+BAA+B,CAAC;oBACpE,OAAO;wBAAC,IAAI,CAAC,oBAAoB,CAAC,WAAW,OAAO,CAAC,EAAE,EAAE,iBAAiB,iBAAiB;qBAAa;gBAC5G;YACA,KAAK,GAAG,0CAA0C;gBAAI;oBAClD,yCAAyC;oBACzC,MAAM,SAAS,EAAE;oBACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;wBAChD,MAAM,SAAS,OAAO,CAAC,EAAE;wBACzB,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,+BAA+B,CAAC,WAAW,QAAQ,kBAAkB;oBAC1F;oBACA,OAAO;gBACX;YACA;gBACI,OAAO;QACf;IACJ;IACA,OAAO,gCAAgC,SAAS,EAAE,MAAM,EAAE,gBAAgB,EAAE,eAAe,EAAE;QACzF,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;QAC3D,IAAI,iBAAiB,eAAe,IAAI,kBAAkB,kBAAkB,iBAAiB,aAAa,GAAG,GAAG;YAC5G,uCAAuC;YACvC,OAAO,IAAI,iLAAA,CAAA,cAAW,CAAC,OAAO,UAAU,EAAE,OAAO,SAAS;QAC9D,OACK;YACD,IAAI;YACJ,IAAI,iBAAiB,iBAAiB,aAAa,GAAG,GAAG;gBACrD,oBAAoB,iBAAiB,aAAa,GAAG;YACzD,OACK,IAAI,iBAAiB,iBAAiB,eAAe,EAAE;gBACxD,oBAAoB,iBAAiB,eAAe;YACxD,OACK;gBACD,oBAAoB;YACxB;YACA,MAAM,WAAW,mMAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,UAAU,YAAY,EAAE,WAAW,gBAAgB,OAAO,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,SAAS,CAAC,sBAAsB,EAAE,mBAAmB;YAC1L,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,OAAO,SAAS,CAAC,IAAI,CAAC,iBAAiB,SAAS,UAAU,EAAE,SAAS,MAAM,EAAE,SAAS,sBAAsB;QACjJ;IACJ;IACA;;KAEC,GACD,OAAO,wBAAwB,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;QAChD,IAAI,kBAAkB,MAAM,eAAe;QAC3C,IAAI,MAAM,WAAW,KAAK,MAAM,gBAAgB,CAAC,kBAAkB;YAC/D,kFAAkF;YAClF;QACJ;QACA,OAAO,KAAK,GAAG,CAAC,MAAM,aAAa,EAAE,kBAAkB,QAAQ;IACnE;IACA;;KAEC,GACD,OAAO,uBAAuB,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;QAC/C,IAAI,kBAAkB,MAAM,eAAe;QAC3C,IAAI,MAAM,WAAW,KAAK,MAAM,gBAAgB,CAAC,kBAAkB;YAC/D,kFAAkF;YAClF;QACJ;QACA,OAAO,KAAK,GAAG,CAAC,iBAAiB,MAAM,aAAa,GAAG,QAAQ;IACnE;IACA,OAAO,UAAU,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,WAAW,EAAE;QAC/D,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;IACzJ;IACA,OAAO,kBAAkB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC1D,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,WAAW,KAAK,KAAK,CAAC,UAAU,aAAa,CAAC,kBAAkB;YACtE,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;QACxI;QACA,OAAO;IACX;IACA,OAAO,WAAW,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,WAAW,EAAE;QAChE,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,SAAS,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;IAC1J;IACA,OAAO,mBAAmB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC3D,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,WAAW,KAAK,KAAK,CAAC,UAAU,aAAa,CAAC,kBAAkB;YACtE,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,SAAS,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;QACzI;QACA,OAAO;IACX;IACA,OAAO,qBAAqB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE;QACzE,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;QACxI;QACA,OAAO;IACX;IACA,OAAO,sBAAsB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE;QAC1E,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE,iBAAiB;QAChJ;QACA,OAAO;IACX;IACA,OAAO,mBAAmB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE;QACvE,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,mMAAA,CAAA,iBAAc,CAAC,MAAM,CAAC,UAAU,YAAY,EAAE,WAAW,OAAO,SAAS,EAAE,iBAAiB;QACtI;QACA,OAAO;IACX;IACA,OAAO,oBAAoB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE;QACxE,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,CAAC,EAAE,GAAG,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,mMAAA,CAAA,iBAAc,CAAC,MAAM,CAAC,UAAU,YAAY,EAAE,UAAU,KAAK,EAAE,OAAO,UAAU,EAAE,iBAAiB;QAC9I;QACA,OAAO;IACX;IACA,OAAO,oBAAoB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,gBAAgB,EAAE,YAAY,EAAE;QAC3F,OAAO,iLAAA,CAAA,cAAW,CAAC,aAAa,CAAC,OAAO,SAAS,CAAC,IAAI,CAAC,iBAAiB,kBAAkB,cAAc;IAC5G;IACA,OAAO,qBAAqB,SAAS,EAAE,MAAM,EAAE,eAAe,EAAE,iBAAiB,EAAE,aAAa,EAAE;QAC9F,OAAO,iLAAA,CAAA,cAAW,CAAC,cAAc,CAAC,OAAO,UAAU,CAAC,IAAI,CAAC,iBAAiB,mBAAmB,eAAe;IAChH;IACA,OAAO,qBAAqB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC7D,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,aAAa,UAAU,gBAAgB,CAAC;YAC9C,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,QAAQ,iBAAiB,gBAAgB;QAC7F;QACA,OAAO;IACX;IACA,OAAO,oCAAoC,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC5E,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,aAAa,UAAU,+BAA+B,CAAC;YAC7D,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,QAAQ,iBAAiB,gBAAgB;QAC7F;QACA,OAAO;IACX;IACA,OAAO,wBAAwB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAChE,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,aAAa,KAAK,KAAK,CAAC,CAAC,UAAU,gBAAgB,CAAC,kBAAkB,UAAU,gBAAgB,CAAC,eAAe,IAAI;YAC1H,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,QAAQ,iBAAiB,gBAAgB;QAC7F;QACA,OAAO;IACX;IACA,OAAO,qBAAqB,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC7D,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,aAAa,UAAU,gBAAgB,CAAC;YAC9C,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,QAAQ,iBAAiB,gBAAgB;QAC7F;QACA,OAAO;IACX;IACA,OAAO,mCAAmC,SAAS,EAAE,OAAO,EAAE,eAAe,EAAE;QAC3E,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,MAAM,EAAE,IAAI,KAAK,IAAK;YAChD,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,iBAAiB,OAAO,SAAS,CAAC,QAAQ,CAAC,UAAU;YAC3D,MAAM,aAAa,UAAU,8BAA8B,CAAC;YAC5D,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,QAAQ,iBAAiB,gBAAgB;QAC7F;QACA,OAAO;IACX;AACJ;AACO,IAAI;AACX,CAAC,SAAU,UAAU;IACjB,MAAM,mBAAmB,SAAU,GAAG;QAClC,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,WAAc,AAAD,EAAE,MAAM;YACtB,OAAO;QACX;QACA,MAAM,gBAAgB;QACtB,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,WAAc,AAAD,EAAE,cAAc,EAAE,GAAG;YACnC,OAAO;QACX;QACA,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,cAAiB,AAAD,EAAE,cAAc,MAAM,KAAK,CAAC,CAAA,GAAA,wKAAA,CAAA,YAAe,AAAD,EAAE,cAAc,MAAM,GAAG;YACpF,OAAO;QACX;QACA,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,cAAiB,AAAD,EAAE,cAAc,EAAE,KAAK,CAAC,CAAA,GAAA,wKAAA,CAAA,WAAc,AAAD,EAAE,cAAc,EAAE,GAAG;YAC3E,OAAO;QACX;QACA,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,cAAiB,AAAD,EAAE,cAAc,KAAK,KAAK,CAAC,CAAA,GAAA,wKAAA,CAAA,WAAc,AAAD,EAAE,cAAc,KAAK,GAAG;YACjF,OAAO;QACX;QACA,OAAO;IACX;IACA,WAAW,QAAQ,GAAG;QAClB,aAAa;QACb,MAAM;YACF;gBACI,MAAM;gBACN,aAAa,CAAC;;;;;;;;;;;;;;IAc1B,CAAC;gBACW,YAAY;gBACZ,QAAQ;oBACJ,QAAQ;oBACR,YAAY;wBAAC;qBAAK;oBAClB,cAAc;wBACV,MAAM;4BACF,QAAQ;4BACR,QAAQ;gCAAC;gCAAQ;gCAAS;gCAAM;gCAAQ;gCAAiB;gCAAiB;gCAAoB;gCAAkB;gCAA2B;gCAA0C;gCAAyC;gCAAe;gCAAkB;gCAAkB;6BAAoB;wBACzS;wBACA,MAAM;4BACF,QAAQ;4BACR,QAAQ;gCAAC;gCAAQ;gCAAe;gCAAa;6BAAW;wBAC5D;wBACA,SAAS;4BACL,QAAQ;4BACR,WAAW;wBACf;wBACA,UAAU;4BACN,QAAQ;4BACR,WAAW;wBACf;oBACJ;gBACJ;YACJ;SACH;IACL;IACA;;KAEC,GACD,WAAW,YAAY,GAAG;QACtB,MAAM;QACN,OAAO;QACP,IAAI;QACJ,MAAM;QACN,eAAe;QACf,eAAe;QACf,kBAAkB;QAClB,wCAAwC;QACxC,yBAAyB;QACzB,gBAAgB;QAChB,uCAAuC;QACvC,aAAa;QACb,gBAAgB;QAChB,gBAAgB;QAChB,mBAAmB;IACvB;IACA;;KAEC,GACD,WAAW,OAAO,GAAG;QACjB,MAAM;QACN,aAAa;QACb,WAAW;QACX,UAAU;IACd;IACA,SAAS,MAAM,IAAI;QACf,IAAI,CAAC,KAAK,EAAE,EAAE;YACV,oBAAoB;YACpB,OAAO;QACX;QACA,IAAI;QACJ,OAAQ,KAAK,EAAE;YACX,KAAK,WAAW,YAAY,CAAC,IAAI;gBAC7B,YAAY,EAAE,kBAAkB;gBAChC;YACJ,KAAK,WAAW,YAAY,CAAC,KAAK;gBAC9B,YAAY,EAAE,mBAAmB;gBACjC;YACJ,KAAK,WAAW,YAAY,CAAC,EAAE;gBAC3B,YAAY,EAAE,gBAAgB;gBAC9B;YACJ,KAAK,WAAW,YAAY,CAAC,IAAI;gBAC7B,YAAY,EAAE,kBAAkB;gBAChC;YACJ,KAAK,WAAW,YAAY,CAAC,aAAa;gBACtC,YAAY,EAAE,2BAA2B;gBACzC;YACJ,KAAK,WAAW,YAAY,CAAC,aAAa;gBACtC,YAAY,EAAE,2BAA2B;gBACzC;YACJ,KAAK,WAAW,YAAY,CAAC,gBAAgB;gBACzC,YAAY,EAAE,8BAA8B;gBAC5C;YACJ,KAAK,WAAW,YAAY,CAAC,sCAAsC;gBAC/D,YAAY,EAAE,oDAAoD;gBAClE;YACJ,KAAK,WAAW,YAAY,CAAC,uBAAuB;gBAChD,YAAY,EAAE,qCAAqC;gBACnD;YACJ,KAAK,WAAW,YAAY,CAAC,cAAc;gBACvC,YAAY,EAAE,4BAA4B;gBAC1C;YACJ,KAAK,WAAW,YAAY,CAAC,qCAAqC;gBAC9D,YAAY,GAAG,mDAAmD;gBAClE;YACJ,KAAK,WAAW,YAAY,CAAC,WAAW;gBACpC,YAAY,GAAG,yBAAyB;gBACxC;YACJ,KAAK,WAAW,YAAY,CAAC,cAAc;gBACvC,YAAY,GAAG,4BAA4B;gBAC3C;YACJ,KAAK,WAAW,YAAY,CAAC,cAAc;gBACvC,YAAY,GAAG,4BAA4B;gBAC3C;YACJ,KAAK,WAAW,YAAY,CAAC,iBAAiB;gBAC1C,YAAY,GAAG,+BAA+B;gBAC9C;YACJ;gBACI,oBAAoB;gBACpB,OAAO;QACf;QACA,IAAI,OAAO,EAAE,aAAa;QAC1B,OAAQ,KAAK,EAAE;YACX,KAAK,WAAW,OAAO,CAAC,IAAI;gBACxB,OAAO,EAAE,aAAa;gBACtB;YACJ,KAAK,WAAW,OAAO,CAAC,WAAW;gBAC/B,OAAO,EAAE,oBAAoB;gBAC7B;YACJ,KAAK,WAAW,OAAO,CAAC,SAAS;gBAC7B,OAAO,EAAE,kBAAkB;gBAC3B;YACJ,KAAK,WAAW,OAAO,CAAC,QAAQ;gBAC5B,OAAO,EAAE,iBAAiB;gBAC1B;QACR;QACA,OAAO;YACH,WAAW;YACX,MAAM;YACN,QAAS,CAAC,CAAC,KAAK,MAAM;YACtB,OAAQ,KAAK,KAAK,IAAI;QAC1B;IACJ;IACA,WAAW,KAAK,GAAG;AACvB,CAAC,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2168, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeEditOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class AutoIndentOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const indentationForSelections = [];\n            for (const selection of selections) {\n                const indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n                if (indentation === null) {\n                    // Auto indentation failed\n                    return;\n                }\n                indentationForSelections.push({ selection, indentation });\n            }\n            const autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n            return this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n        }\n        return;\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _findActualIndentationForSelection(config, model, selection, ch) {\n        const actualIndentation = getIndentActionForType(config, model, selection, ch, {\n            shiftIndent: (indentation) => {\n                return shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        const currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n        if (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n            return null;\n        }\n        return actualIndentation;\n    }\n    static _getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose) {\n        const commands = indentationForSelections.map(({ selection, indentation }) => {\n            if (autoClosingPairClose !== null) {\n                // Apply both auto closing pair edits and auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n                return new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n            }\n            else {\n                // Apply only auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n                return typeCommand(indentationEdit.range, indentationEdit.text, false);\n            }\n        });\n        const editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, editOptions);\n    }\n    static _getEditFromIndentationAndSelection(config, model, indentation, selection, ch, includeChInEdit = true) {\n        const startLineNumber = selection.startLineNumber;\n        const firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n        let text = config.normalizeIndentation(indentation);\n        if (firstNonWhitespaceColumn !== 0) {\n            const startLine = model.getLineContent(startLineNumber);\n            text += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n        }\n        text += includeChInEdit ? ch : '';\n        const range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n        return { range, text };\n    }\n}\nexport class AutoClosingOvertypeOperation {\n    static getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n        }\n        return;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n    static getEdits(config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        return;\n    }\n}\nexport class AutoClosingOpenCharTypeOperation {\n    static getEdits(config, model, selections, ch, chIsAlreadyTyped, isDoingComposition) {\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n            if (autoClosingPairClose !== null) {\n                return this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n            }\n        }\n        return;\n    }\n    static _runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n}\nexport class SurroundSelectionOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(config, selections, ch);\n        }\n        return;\n    }\n    static _runSurroundSelectionType(config, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\nexport class InterceptorElectricCharOperation {\n    static getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition) {\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        return;\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n}\nexport class SimpleCharacterTypeOperation {\n    static getEdits(prevEditOperationType, selections, ch) {\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class EnterOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        return;\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = unshiftIndent(config, r.indentation);\n                return typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class PasteOperation {\n    static getEdits(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substring(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substring(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\nexport class CompositionOperation {\n    static getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n}\nexport class TypeWithoutInterceptorsOperation {\n    static getEdits(prevEditOperationType, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class TabOperation {\n    static getCommands(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n}\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter) {\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    _computeCursorStateWithRange(model, range, helper) {\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        const text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = -closeCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(autoIndentationEdit, selection, openCharacter, closeCharacter) {\n        const text = openCharacter + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = openCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n        this._autoIndentationEdit = autoIndentationEdit;\n        this._autoClosingEdit = { range: selection, text };\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n        builder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        if (inverseEditOperations.length !== 2) {\n            throw new Error('There should be two inverse edit operations!');\n        }\n        const range1 = inverseEditOperations[0].range;\n        const range2 = inverseEditOperations[1].range;\n        const range = range1.plusRange(range2);\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\nfunction isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n        return false;\n    }\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n        return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n        const selection = selections[i];\n        if (!selection.isEmpty()) {\n            return false;\n        }\n        const position = selection.getPosition();\n        const lineText = model.getLineContent(position.lineNumber);\n        const afterCharacter = lineText.charAt(position.column - 1);\n        if (afterCharacter !== ch) {\n            return false;\n        }\n        // Do not over-type quotes after a backslash\n        const chIsQuote = isQuote(ch);\n        const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n        if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n            return false;\n        }\n        // Must over-type a closing character typed by the editor\n        if (config.autoClosingOvertype === 'auto') {\n            let found = false;\n            for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                const autoClosedCharacter = autoClosedCharacters[j];\n                if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    }\n    else {\n        return new ReplaceCommand(range, text, true);\n    }\n}\nexport function shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n        return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n    }\n    else {\n        // Character is a bracket\n        return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3150, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { AutoClosingOpenCharTypeOperation, AutoClosingOvertypeOperation, AutoClosingOvertypeWithInterceptorsOperation, AutoIndentOperation, CompositionOperation, EnterOperation, InterceptorElectricCharOperation, PasteOperation, shouldSurroundChar, SimpleCharacterTypeOperation, SurroundSelectionOperation, TabOperation, TypeWithoutInterceptorsOperation } from './cursorTypeEditOperations.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        return PasteOperation.getEdits(config, model, selections, text, pasteOnNewLine, multicursorText);\n    }\n    static tab(config, model, selections) {\n        return TabOperation.getCommands(config, model, selections);\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        return CompositionOperation.getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingOvertypeEdits = AutoClosingOvertypeWithInterceptorsOperation.getEdits(config, model, selections, autoClosedCharacters, ch);\n        if (autoClosingOvertypeEdits !== undefined) {\n            return autoClosingOvertypeEdits;\n        }\n        const autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, true, false);\n        if (autoClosingOpenCharEdits !== undefined) {\n            return autoClosingOpenCharEdits;\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        const enterEdits = EnterOperation.getEdits(config, model, selections, ch, isDoingComposition);\n        if (enterEdits !== undefined) {\n            return enterEdits;\n        }\n        const autoIndentEdits = AutoIndentOperation.getEdits(config, model, selections, ch, isDoingComposition);\n        if (autoIndentEdits !== undefined) {\n            return autoIndentEdits;\n        }\n        const autoClosingOverTypeEdits = AutoClosingOvertypeOperation.getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch);\n        if (autoClosingOverTypeEdits !== undefined) {\n            return autoClosingOverTypeEdits;\n        }\n        const autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, false, isDoingComposition);\n        if (autoClosingOpenCharEdits !== undefined) {\n            return autoClosingOpenCharEdits;\n        }\n        const surroundSelectionEdits = SurroundSelectionOperation.getEdits(config, model, selections, ch, isDoingComposition);\n        if (surroundSelectionEdits !== undefined) {\n            return surroundSelectionEdits;\n        }\n        const interceptorElectricCharOperation = InterceptorElectricCharOperation.getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition);\n        if (interceptorElectricCharOperation !== undefined) {\n            return interceptorElectricCharOperation;\n        }\n        return SimpleCharacterTypeOperation.getEdits(prevEditOperationType, selections, ch);\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        return TypeWithoutInterceptorsOperation.getEdits(prevEditOperationType, selections, str);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3330, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3451, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMax, findFirstMin } from '../../../base/common/arraysFind.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findFirstMin(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMax(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3654, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AACvF,MAAM;IACT,YAAY,KAAK,EAAE,SAAS,EAAE,oBAAoB,EAAE,YAAY,CAAE;QAC9D,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,oBAAoB,GAAG;QAC5B,IAAI,CAAC,YAAY,GAAG;IACxB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3675, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations } from './cursorTypeOperations.js';\nimport { BaseTypeWithAutoClosingCommand } from './cursorTypeEditOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const revealViewSelections = [primaryCursor.viewState.selection];\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof BaseTypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}