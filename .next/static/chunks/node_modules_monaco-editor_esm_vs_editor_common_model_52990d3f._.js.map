{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;AAC9F;AACA;;;AACO,MAAM;IACT,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG,IAAI,YAAY,OAAO,MAAM;QAC9C,IAAI,CAAC,mBAAmB,GAAG,IAAI,WAAW;QAC1C,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG,CAAC;IACnC;IACA,aAAa,WAAW,EAAE,YAAY,EAAE;QACpC,cAAc,CAAA,GAAA,0KAAA,CAAA,WAAQ,AAAD,EAAE;QACvB,MAAM,YAAY,IAAI,CAAC,MAAM;QAC7B,MAAM,eAAe,IAAI,CAAC,SAAS;QACnC,MAAM,kBAAkB,aAAa,MAAM;QAC3C,IAAI,oBAAoB,GAAG;YACvB,OAAO;QACX;QACA,IAAI,CAAC,MAAM,GAAG,IAAI,YAAY,UAAU,MAAM,GAAG;QACjD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,QAAQ,CAAC,GAAG,cAAc;QACpD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,QAAQ,CAAC,cAAc,cAAc;QAC/D,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc;QAC9B,IAAI,cAAc,IAAI,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE;YAC/C,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG,cAAc;QAChD;QACA,IAAI,CAAC,SAAS,GAAG,IAAI,YAAY,IAAI,CAAC,MAAM,CAAC,MAAM;QACnD,IAAI,IAAI,CAAC,mBAAmB,CAAC,EAAE,IAAI,GAAG;YAClC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,aAAa,QAAQ,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG;QAC9E;QACA,OAAO;IACX;IACA,SAAS,KAAK,EAAE,KAAK,EAAE;QACnB,QAAQ,CAAA,GAAA,0KAAA,CAAA,WAAQ,AAAD,EAAE;QACjB,QAAQ,CAAA,GAAA,0KAAA,CAAA,WAAQ,AAAD,EAAE;QACjB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,OAAO;YAC9B,OAAO;QACX;QACA,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;QACrB,IAAI,QAAQ,IAAI,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE;YACzC,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG,QAAQ;QAC1C;QACA,OAAO;IACX;IACA,aAAa,UAAU,EAAE,KAAK,EAAE;QAC5B,aAAa,CAAA,GAAA,0KAAA,CAAA,WAAQ,AAAD,EAAE;QACtB,QAAQ,CAAA,GAAA,0KAAA,CAAA,WAAQ,AAAD,EAAE;QACjB,MAAM,YAAY,IAAI,CAAC,MAAM;QAC7B,MAAM,eAAe,IAAI,CAAC,SAAS;QACnC,IAAI,cAAc,UAAU,MAAM,EAAE;YAChC,OAAO;QACX;QACA,MAAM,WAAW,UAAU,MAAM,GAAG;QACpC,IAAI,SAAS,UAAU;YACnB,QAAQ;QACZ;QACA,IAAI,UAAU,GAAG;YACb,OAAO;QACX;QACA,IAAI,CAAC,MAAM,GAAG,IAAI,YAAY,UAAU,MAAM,GAAG;QACjD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,QAAQ,CAAC,GAAG,aAAa;QACnD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,QAAQ,CAAC,aAAa,QAAQ;QACxD,IAAI,CAAC,SAAS,GAAG,IAAI,YAAY,IAAI,CAAC,MAAM,CAAC,MAAM;QACnD,IAAI,aAAa,IAAI,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE;YAC9C,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG,aAAa;QAC/C;QACA,IAAI,IAAI,CAAC,mBAAmB,CAAC,EAAE,IAAI,GAAG;YAClC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,aAAa,QAAQ,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG;QAC9E;QACA,OAAO;IACX;IACA,cAAc;QACV,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,GAAG;YAC1B,OAAO;QACX;QACA,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;IACnD;IACA;;;KAGC,GACD,aAAa,KAAK,EAAE;QAChB,IAAI,QAAQ,GAAG;YACX,OAAO;QACX;QACA,QAAQ,CAAA,GAAA,0KAAA,CAAA,WAAQ,AAAD,EAAE;QACjB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B;IACA,cAAc,KAAK,EAAE;QACjB,IAAI,SAAS,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE;YACtC,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM;QAChC;QACA,IAAI,aAAa,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG;QAC/C,IAAI,eAAe,GAAG;YAClB,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE;YAClC;QACJ;QACA,IAAI,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAC7B,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;QACjC;QACA,IAAK,IAAI,IAAI,YAAY,KAAK,OAAO,IAAK;YACtC,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE;QAC9D;QACA,IAAI,CAAC,mBAAmB,CAAC,EAAE,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE;QACpE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM;IAChC;IACA,WAAW,GAAG,EAAE;QACZ,MAAM,KAAK,KAAK,CAAC;QACjB,oDAAoD;QACpD,IAAI,CAAC,WAAW;QAChB,IAAI,MAAM;QACV,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;QAChC,IAAI,MAAM;QACV,IAAI,UAAU;QACd,IAAI,WAAW;QACf,MAAO,OAAO,KAAM;YAChB,MAAM,MAAO,CAAC,OAAO,GAAG,IAAI,IAAK;YACjC,UAAU,IAAI,CAAC,SAAS,CAAC,IAAI;YAC7B,WAAW,UAAU,IAAI,CAAC,MAAM,CAAC,IAAI;YACrC,IAAI,MAAM,UAAU;gBAChB,OAAO,MAAM;YACjB,OACK,IAAI,OAAO,SAAS;gBACrB,MAAM,MAAM;YAChB,OACK;gBACD;YACJ;QACJ;QACA,OAAO,IAAI,uBAAuB,KAAK,MAAM;IACjD;AACJ;AAMO,MAAM;IACT,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,cAAc,GAAG,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,EAAE;QACpB,IAAI,CAAC,WAAW,GAAG,EAAE;IACzB;IACA;;KAEC,GACD,cAAc;QACV,IAAI,CAAC,YAAY;QACjB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM;IAClC;IACA;;;KAGC,GACD,aAAa,KAAK,EAAE;QAChB,IAAI,CAAC,YAAY;QACjB,IAAI,UAAU,GAAG;YACb,OAAO;QACX;QACA,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE;IACrC;IACA;;KAEC,GACD,WAAW,GAAG,EAAE;QACZ,IAAI,CAAC,YAAY;QACjB,MAAM,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI;QACjC,MAAM,iBAAiB,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,GAAG;QAC5D,OAAO,IAAI,uBAAuB,KAAK,MAAM;IACjD;IACA,aAAa,KAAK,EAAE,WAAW,EAAE;QAC7B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO;QAC3B,IAAI,CAAC,WAAW,CAAC;IACrB;IACA,aAAa,WAAW,EAAE,SAAS,EAAE;QACjC,IAAI,CAAC,OAAO,GAAG,CAAA,GAAA,4KAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,OAAO,EAAE,aAAa;QACtD,IAAI,CAAC,WAAW,CAAC;IACrB;IACA,YAAY,KAAK,EAAE;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,cAAc,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ;IAChE;IACA,eAAe;QACX,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf;QACJ;QACA,IAAK,IAAI,IAAI,IAAI,CAAC,cAAc,GAAG,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,KAAK,IAAK;YAC3E,MAAM,QAAQ,IAAI,CAAC,OAAO,CAAC,EAAE;YAC7B,MAAM,WAAW,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,GAAG;YAClD,IAAI,CAAC,UAAU,CAAC,EAAE,GAAG,WAAW;YAChC,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;gBAC5B,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,GAAG;YACrC;QACJ;QACA,cAAc;QACd,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM;QAC5C,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,EAAE;QACrE,gBAAgB;QAChB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG;IAChD;IACA,SAAS,KAAK,EAAE,KAAK,EAAE;QACnB,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,OAAO;YAC/B,YAAY;YACZ;QACJ;QACA,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG;QACtB,IAAI,CAAC,WAAW,CAAC;IACrB;AACJ;AACO,MAAM;IACT,YAAY,KAAK,EAAE,SAAS,CAAE;QAC1B,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,4BAA4B,GAAG;QACpC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,SAAS,GAAG;IACrB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;;;;;;;;;;;;;;;AAC9F;AACA;AACA;;;;AAIO,SAAS,WAAW,cAAc,EAAE,gBAAgB,EAAE,YAAY,EAAE,cAAc;IACrF,OAAO,AAAC,mBAAmB,eACrB,SAAS,eAAe,gBAAgB,kBACxC,SAAS,GAAG,iBAAiB;AACvC;AACO,MAAM,aAAa;AACnB,SAAS,aAAa,MAAM;IAC/B,OAAO,WAAW;AACtB;AACA;;;CAGC,GACD,IAAI;AACJ,MAAM,SAAS,KAAK;AAIb,SAAS,SAAS,SAAS,EAAE,WAAW;IAC3C,iEAAiE;IACjE,uDAAuD;IACvD,mEAAmE;IACnE,kGAAkG;IAClG,OAAQ,YAAY,SAAS;AACjC;AACO,SAAS,YAAY,MAAM;IAC9B,MAAM,IAAI;IACV,MAAM,YAAY,KAAK,KAAK,CAAC,IAAI;IACjC,MAAM,cAAc,IAAI,YAAY;IACpC,OAAO,IAAI,0LAAA,CAAA,aAAU,CAAC,WAAW;AACrC;AACO,SAAS,mBAAmB,MAAM;IACrC,OAAO,KAAK,KAAK,CAAC,SAAS;AAC/B;AAIO,SAAS,oCAAoC,MAAM;IACtD,OAAO;AACX;AACO,SAAS,UAAU,EAAE,EAAE,EAAE;IAC5B,IAAI,IAAI,KAAK;IACb,IAAI,MAAM,QAAQ;QACd,IAAI,IAAK,KAAK;IAClB;IACA,OAAO;AACX;AACO,SAAS,WAAW,KAAK,EAAE,QAAQ;IACtC,OAAO,MAAM,MAAM,CAAC,CAAC,GAAG,IAAM,UAAU,GAAG,SAAS,KAAK;AAC7D;AACO,SAAS,aAAa,OAAO,EAAE,OAAO;IACzC,OAAO,YAAY;AACvB;AAIO,SAAS,sBAAsB,OAAO,EAAE,OAAO;IAClD,MAAM,KAAK;IACX,MAAM,KAAK;IACX,MAAM,OAAO,KAAK;IAClB,IAAI,QAAQ,GAAG;QACX,6DAA6D;QAC7D,uFAAuF;QACvF,OAAO;IACX;IACA,MAAM,aAAa,KAAK,KAAK,CAAC,KAAK;IACnC,MAAM,aAAa,KAAK,KAAK,CAAC,KAAK;IACnC,MAAM,YAAY,KAAK,aAAa;IACpC,IAAI,eAAe,YAAY;QAC3B,MAAM,YAAY,KAAK,aAAa;QACpC,OAAO,SAAS,GAAG,YAAY;IACnC,OACK;QACD,OAAO,SAAS,aAAa,YAAY;IAC7C;AACJ;AACO,SAAS,eAAe,OAAO,EAAE,OAAO;IAC3C,kDAAkD;IAClD,OAAO,UAAU;AACrB;AACO,SAAS,oBAAoB,OAAO,EAAE,OAAO;IAChD,OAAO,WAAW;AACtB;AACO,SAAS,uBAAuB,OAAO,EAAE,OAAO;IACnD,OAAO,WAAW;AACtB;AACO,SAAS,iBAAiB,QAAQ;IACrC,OAAO,SAAS,SAAS,UAAU,GAAG,GAAG,SAAS,MAAM,GAAG;AAC/D;AACO,SAAS,eAAe,WAAW,EAAE,SAAS;IACjD,MAAM,IAAI;IACV,MAAM,YAAY,KAAK,KAAK,CAAC,IAAI;IACjC,MAAM,WAAW,IAAI,YAAY;IACjC,MAAM,KAAK;IACX,MAAM,aAAa,KAAK,KAAK,CAAC,KAAK;IACnC,MAAM,YAAY,KAAK,aAAa;IACpC,OAAO,IAAI,qLAAA,CAAA,QAAK,CAAC,YAAY,GAAG,WAAW,GAAG,aAAa,GAAG,YAAY;AAC9E;AACO,SAAS,eAAe,GAAG;IAC9B,MAAM,QAAQ,CAAA,GAAA,6KAAA,CAAA,aAAU,AAAD,EAAE;IACzB,OAAO,SAAS,MAAM,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,MAAM;AACpE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 933, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1044, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;;;AAC9F,MAAM,WAAW,EAAE;AAKZ,MAAM;IACT,MAAO;QAAE,IAAI,CAAC,KAAK,GAAG,IAAI,MAAM;IAAM,CAAC;IACvC,OAAO,OAAO,KAAK,EAAE,eAAe,EAAE;QAClC,IAAI,SAAS,OAAO,gBAAgB,MAAM,KAAK,GAAG;YAC9C,yFAAyF;YACzF,IAAI,SAAS,kBAAkB,KAAK,CAAC,MAAM;YAC3C,IAAI,CAAC,QAAQ;gBACT,SAAS,IAAI,kBAAkB,OAAO;gBACtC,kBAAkB,KAAK,CAAC,MAAM,GAAG;YACrC;YACA,OAAO;QACX;QACA,OAAO,IAAI,kBAAkB,OAAO;IACxC;IACA,MAAO;QAAE,IAAI,CAAC,KAAK,GAAG,kBAAkB,MAAM,CAAC,GAAG;IAAW,CAAC;IAC9D,OAAO,WAAW;QACd,OAAO,IAAI,CAAC,KAAK;IACrB;IACA,YAAY,KAAK,EAAE,eAAe,CAAE;QAChC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,eAAe,GAAG;IAC3B;IACA,IAAI,KAAK,EAAE,WAAW,EAAE;QACpB,MAAM,MAAM,YAAY,MAAM,CAAC;QAC/B,IAAI,MAAM,OAAO,GAAG,gBAAgB;QACpC,IAAI,QAAQ,GAAG;YACX,YAAY;YACZ,MAAM,UAAU,AAAC,KAAK,MAAO,IAAI,CAAC,KAAK;YACvC,IAAI,YAAY,IAAI,CAAC,KAAK,EAAE;gBACxB,OAAO,IAAI;YACf;YACA,OAAO,kBAAkB,MAAM,CAAC,SAAS,IAAI,CAAC,eAAe;QACjE;QACA;QACA,MAAM,WAAW,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;QAC5C,MAAO,SAAS,MAAM,GAAG,IAAK;YAC1B,SAAS,IAAI,CAAC;QAClB;QACA,QAAQ,CAAC,IAAI,IAAI,KAAK,CAAC,MAAM,EAAE;QAC/B,OAAO,kBAAkB,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE;IAChD;IACA,MAAM,KAAK,EAAE;QACT,MAAM,SAAS,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;QACvC,IAAI,IAAI,CAAC,eAAe,KAAK,YAAY,MAAM,eAAe,KAAK,UAAU;YACzE,YAAY;YACZ,IAAI,WAAW,IAAI,CAAC,KAAK,EAAE;gBACvB,OAAO,IAAI;YACf;YACA,IAAI,WAAW,MAAM,KAAK,EAAE;gBACxB,OAAO;YACX;YACA,OAAO,kBAAkB,MAAM,CAAC,QAAQ;QAC5C;QACA,oDAAoD;QACpD,MAAM,WAAW,EAAE;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,eAAe,CAAC,MAAM,GAAG,IAAK;YAC1F,MAAM,QAAQ,IAAI,CAAC,eAAe,CAAC,EAAE,IAAI;YACzC,MAAM,QAAQ,MAAM,eAAe,CAAC,EAAE,IAAI;YAC1C,SAAS,IAAI,CAAC,QAAQ;QAC1B;QACA,OAAO,kBAAkB,MAAM,CAAC,QAAQ;IAC5C;IACA,WAAW,KAAK,EAAE;QACd,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK,MAAM,GAAG;YAClC,OAAO;QACX;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,eAAe,CAAC,MAAM,GAAG,IAAK;YAC1F,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,GAAG,MAAM,eAAe,CAAC,EAAE,MAAM,GAAG;gBAC5D,OAAO;YACX;QACJ;QACA,OAAO;IACX;AACJ;AACO,MAAM,sBAAsB;IAC/B,QAAO,KAAK;QACR,OAAO;IACX;AACJ;AAIO,MAAM;IACT,aAAc;QACV,IAAI,CAAC,KAAK,GAAG,IAAI;IACrB;IACA,OAAO,KAAK,EAAE;QACV,IAAI,WAAW,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAC9B,IAAI,aAAa,WAAW;YACxB,WAAW,IAAI,CAAC,KAAK,CAAC,IAAI;YAC1B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO;QAC1B;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1155, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1651, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1942, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2061, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2241, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2366, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2490, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;AACA;;;;AACO,SAAS,qBAAqB,iBAAiB,EAAE,kBAAkB;IACtE,IAAI,kBAAkB,MAAM,KAAK,GAAG;QAChC,OAAO;IACX;IACA,IAAI,mBAAmB,MAAM,KAAK,GAAG;QACjC,OAAO;IACX;IACA,6BAA6B;IAC7B,MAAM,YAAY,IAAI,4KAAA,CAAA,aAAU,CAAC,gBAAgB;IACjD,qDAAqD;IACrD,MAAM,YAAY,gBAAgB;IAClC,UAAU,IAAI,CAAC;QAAE,UAAU;QAAO,cAAc;QAAW,aAAa;IAAU,IAAI,kCAAkC;IACxH,6BAA6B;IAC7B,IAAI,UAAU,UAAU,OAAO;IAC/B;;KAEC,GACD,SAAS,4BAA4B,QAAQ;QACzC,IAAI,aAAa,WAAW;YACxB,MAAM,MAAM,UAAU,SAAS,CAAC,CAAA,IAAK,SAAS,EAAE;YAChD,IAAI,SAAS;gBACT,IAAI,OAAO,CAAC;YAChB;YACA,OAAO;QACX;QACA,MAAM,SAAS,EAAE;QACjB,MAAO,WAAW,CAAC,CAAA,GAAA,wOAAA,CAAA,eAAY,AAAD,EAAE,UAAW;YACvC,MAAM,CAAC,MAAM,cAAc,GAAG,QAAQ,OAAO,CAAC;YAC9C,OAAO,IAAI,CAAC;YACZ,WAAW,CAAA,GAAA,wOAAA,CAAA,wBAAqB,AAAD,EAAE,KAAK,WAAW,EAAE;YACnD,UAAU,iBAAiB,UAAU,OAAO;QAChD;QACA,IAAI,CAAC,CAAA,GAAA,wOAAA,CAAA,eAAY,AAAD,EAAE,WAAW;YACzB,OAAO,IAAI,CAAC,IAAI,cAAc,OAAO,UAAU;QACnD;QACA,OAAO;IACX;IACA,MAAM,SAAS,EAAE;IACjB,SAAS,SAAS,WAAW,EAAE,SAAS,EAAE,SAAS;QAC/C,IAAI,OAAO,MAAM,GAAG,KAAK,CAAA,GAAA,wOAAA,CAAA,eAAY,AAAD,EAAE,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,SAAS,EAAE,cAAc;YACrF,MAAM,aAAa,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE;YAC5C,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,GAAG,IAAI,0PAAA,CAAA,eAAY,CAAC,WAAW,WAAW,EAAE,WAAW,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,WAAW,SAAS,EAAE;QACpH,OACK;YACD,OAAO,IAAI,CAAC;gBAAE;gBAAa;gBAAW;YAAU;QACpD;IACJ;IACA,IAAI,WAAW,wOAAA,CAAA,aAAU;IACzB,KAAK,MAAM,UAAU,UAAW;QAC5B,MAAM,YAAY,4BAA4B,OAAO,YAAY;QACjE,IAAI,OAAO,QAAQ,EAAE;YACjB,MAAM,WAAW,CAAA,GAAA,wOAAA,CAAA,aAAU,AAAD,EAAE,WAAW,CAAA,IAAK,EAAE,YAAY;YAC1D,MAAM,cAAc,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,UAAU;YACxC,SAAS,UAAU,aAAa,OAAO,WAAW;YAClD,WAAW;QACf,OACK;YACD,KAAK,MAAM,MAAM,UAAW;gBACxB,MAAM,gBAAgB;gBACtB,WAAW,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,UAAU,GAAG,YAAY;gBAC9C,IAAI,GAAG,QAAQ,EAAE;oBACb,SAAS,eAAe,UAAU,GAAG,WAAW;gBACpD;YACJ;QACJ;IACJ;IACA,OAAO;AACX;AACA,MAAM;IACF,YACA;;KAEC,GACD,QAAQ,EAAE,YAAY,EAAE,WAAW,CAAE;QACjC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,QAAQ,WAAW,EAAE;QACjB,MAAM,uBAAuB,CAAA,GAAA,wOAAA,CAAA,wBAAqB,AAAD,EAAE,aAAa,IAAI,CAAC,WAAW;QAChF,IAAI,CAAA,GAAA,wOAAA,CAAA,eAAY,AAAD,EAAE,sBAAsB,wOAAA,CAAA,aAAU,GAAG;YAChD,OAAO;gBAAC,IAAI;gBAAE;aAAU;QAC5B,OACK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACpB,OAAO;gBACH,IAAI,cAAc,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,EAAE;gBACpD,IAAI,cAAc,IAAI,CAAC,QAAQ,EAAE,wOAAA,CAAA,aAAU,EAAE;aAChD;QACL,OACK;YACD,OAAO;gBACH,IAAI,cAAc,IAAI,CAAC,QAAQ,EAAE,aAAa;gBAC9C,IAAI,cAAc,IAAI,CAAC,QAAQ,EAAE,sBAAsB;aAC1D;QACL;IACJ;IACA,WAAW;QACP,OAAO,GAAG,IAAI,CAAC,QAAQ,GAAG,MAAM,IAAI,CAAC,EAAE,CAAA,GAAA,wOAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,CAAA,GAAA,wOAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,WAAW,GAAG;IAC/G;AACJ;AACA,SAAS,gBAAgB,aAAa;IAClC,MAAM,SAAS,EAAE;IACjB,IAAI,aAAa,wOAAA,CAAA,aAAU;IAC3B,KAAK,MAAM,gBAAgB,cAAe;QACtC,MAAM,cAAc,CAAA,GAAA,wOAAA,CAAA,wBAAqB,AAAD,EAAE,YAAY,aAAa,WAAW;QAC9E,IAAI,CAAC,CAAA,GAAA,wOAAA,CAAA,eAAY,AAAD,EAAE,cAAc;YAC5B,OAAO,IAAI,CAAC,IAAI,cAAc,OAAO,aAAa;QACtD;QACA,MAAM,eAAe,CAAA,GAAA,wOAAA,CAAA,wBAAqB,AAAD,EAAE,aAAa,WAAW,EAAE,aAAa,SAAS;QAC3F,OAAO,IAAI,CAAC,IAAI,cAAc,MAAM,cAAc,aAAa,SAAS;QACxE,aAAa,aAAa,SAAS;IACvC;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2626, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2979, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3695, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3799, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4177, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;;AACO,MAAM,sBAAsB,+KAAA,CAAA,aAAU;IACzC,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,UAAU;QACN,KAAK,CAAC;QACN,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,oBAAoB;QAChB,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,MAAM,IAAI,MAAM;QACpB;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4206, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F,GAC9F;;;;CAIC;;;AACM,SAAS,mBAAmB,IAAI,EAAE,OAAO;IAC5C,IAAI,SAAS;IACb,IAAI,IAAI;IACR,MAAM,MAAM,KAAK,MAAM;IACvB,MAAO,IAAI,IAAK;QACZ,MAAM,SAAS,KAAK,UAAU,CAAC;QAC/B,IAAI,WAAW,GAAG,kBAAkB,KAAI;YACpC;QACJ,OACK,IAAI,WAAW,EAAE,gBAAgB,KAAI;YACtC,SAAS,SAAS,SAAS,UAAU;QACzC,OACK;YACD;QACJ;QACA;IACJ;IACA,IAAI,MAAM,KAAK;QACX,OAAO,CAAC,GAAG,mCAAmC;IAClD;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4242, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4643, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4839, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5806, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6164, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7635, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8100, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8247, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;;AAKO,MAAM;IACT,YAAY,QAAQ,CAAE;QAClB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG,EAAE;IACpB;IACA,IAAI,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAC5B,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM;QAC7B;QACA,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA,IAAI,KAAK,EAAE,KAAK,EAAE;QACd,MAAO,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE;YAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ;QACnD;QACA,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;IACzB;IACA,QAAQ,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE;QACjC,IAAI,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAC7B;QACJ;QACA,IAAI,cAAc,GAAG;YACjB,IAAI,CAAC,MAAM,CAAC,OAAO;YACnB;QACJ,OACK,IAAI,cAAc,GAAG;YACtB,IAAI,CAAC,MAAM,CAAC,OAAO;YACnB;QACJ;QACA,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG;QACpC,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ;QACxC,MAAM,YAAY,UAAU,WAAW,IAAI,CAAC,QAAQ;QACpD,IAAI,CAAC,MAAM,GAAG,OAAO,MAAM,CAAC,WAAW;IAC3C;IACA,OAAO,WAAW,EAAE,WAAW,EAAE;QAC7B,IAAI,gBAAgB,KAAK,eAAe,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACxD;QACJ;QACA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa;IACpC;IACA,OAAO,WAAW,EAAE,WAAW,EAAE;QAC7B,IAAI,gBAAgB,KAAK,eAAe,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACxD;QACJ;QACA,MAAM,MAAM,EAAE;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;YAClC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ;QAC1B;QACA,IAAI,CAAC,MAAM,GAAG,CAAA,GAAA,4KAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,MAAM,EAAE,aAAa;IACxD;AACJ;AACA,SAAS,UAAU,MAAM,EAAE,KAAK;IAC5B,MAAM,MAAM,EAAE;IACd,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC7B,GAAG,CAAC,EAAE,GAAG;IACb;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8318, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8759, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8868, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;AACA;;;;AACO,MAAM,yBAAyB,uLAAA,CAAA,iBAAc;IAChD,YAAY,kBAAkB,EAAE,eAAe,EAAE,SAAS,EAAE,UAAU,CAAE;QACpE,KAAK,CAAC,iBAAiB,WAAW;QAClC,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,oBAAoB,GAAG;QAC5B,IAAI,CAAC,WAAW;IACpB;IACA,cAAc;QACV,MAAM,cAAc,IAAI,CAAC,aAAa;QACtC,IAAI,CAAC,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,eAAe,KAAK,aAAa;YACpE,IAAI,CAAC,eAAe,GAAG;YACvB,IAAI,CAAC,oBAAoB,GAAG,iLAAA,CAAA,iCAA8B,CAAC,GAAG,CAAC;QACnE;IACJ;IACA,cAAc,UAAU,EAAE;QACtB,MAAM,UAAU,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;QAC/C,IAAI,IAAI,CAAC,oBAAoB,EAAE;YAC3B,MAAM,YAAY,IAAI,CAAC,oBAAoB,CAAC,eAAe,CAAC,YAAY,IAAI,CAAC,UAAU;YACvF,IAAI,WAAW;gBACX,OAAO,IAAI,4LAAA,CAAA,aAAU,CAAC,WAAW,SAAS,IAAI,CAAC,gBAAgB;YACnE;QACJ;QACA,OAAO,4LAAA,CAAA,aAAU,CAAC,WAAW,CAAC,SAAS,IAAI,CAAC,gBAAgB;IAChE;IACA,kBAAkB,uBAAuB,IAAI,EAAE;QAC3C,IAAI,sBAAsB;YACtB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBACzB,uBAAuB;gBACvB,QAAQ;oBACJ;wBACI,gBAAgB;wBAChB,cAAc,IAAI,CAAC,UAAU,CAAC,YAAY;oBAC9C;iBACH;YACL;QACJ;QACA,IAAI,CAAC,WAAW;IACpB;IACA,0BAA0B;IACtB,sDAAsD;IAC1D;IACA,uBAAuB,CAAC,EAAE;QACtB,IAAI,EAAE,OAAO,EAAE;YACX,iFAAiF;YACjF,IAAI,CAAC,iBAAiB,CAAC;QAC3B;IACJ;IACA,kBAAkB,UAAU,EAAE;IAC1B,0BAA0B;IAC9B;IACA,yBAAyB,UAAU,EAAE;QACjC,mDAAmD;QACnD,OAAO;IACX;IACA,kBAAkB,UAAU,EAAE;QAC1B,mDAAmD;QACnD,OAAO;IACX;IACA,iCAAiC,UAAU,EAAE,MAAM,EAAE,SAAS,EAAE;QAC5D,wGAAwG;QACxG,OAAO,EAAE,2BAA2B;IACxC;IACA,qBAAqB,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE;QAC5C,0DAA0D;QAC1D,OAAO;IACX;IACA,IAAI,YAAY;QACZ,+DAA+D;QAC/D,MAAM,UAAU,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,MAAM;QAC5E,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8958, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAW9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3BA,IAAI,aAAa,AAAC,IAAI,IAAI,IAAI,CAAC,UAAU,IAAK,SAAU,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI;IACjF,IAAI,IAAI,UAAU,MAAM,EAAE,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,wBAAwB,CAAC,QAAQ,OAAO,MAAM;IAC3H,IAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,QAAQ,KAAK,YAAY,IAAI,QAAQ,QAAQ,CAAC,YAAY,QAAQ,KAAK;SACpH,IAAK,IAAI,IAAI,WAAW,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK,IAAI,IAAI,UAAU,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,IAAI,EAAE,KAAK,IAAI,IAAI,EAAE,QAAQ,KAAK,KAAK,EAAE,QAAQ,IAAI,KAAK;IAChJ,OAAO,IAAI,KAAK,KAAK,OAAO,cAAc,CAAC,QAAQ,KAAK,IAAI;AAChE;AACA,IAAI,UAAU,AAAC,IAAI,IAAI,IAAI,CAAC,OAAO,IAAK,SAAU,UAAU,EAAE,SAAS;IACnE,OAAO,SAAU,MAAM,EAAE,GAAG;QAAI,UAAU,QAAQ,KAAK;IAAa;AACxE;AACA,IAAI;;;;;;;;;;;;;;;;;;;AAmBJ,IAAI,4BAA4B,8BAA8B,MAAM,kCAAkC,8LAAA,CAAA,gBAAa;IAC/G,YAAY,UAAU,EAAE,0BAA0B,EAAE,WAAW,EAAE,cAAc,EAAE,gBAAgB,EAAE,6BAA6B,EAAE,kBAAkB,CAAE;QAClJ,KAAK;QACL,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,0BAA0B,GAAG;QAClC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,6BAA6B,GAAG;QACrC,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,eAAe,GAAG,IAAI,mMAAA,CAAA,oBAAiB,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe;QAClF,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,2KAAA,CAAA,UAAO;QACtD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK;QAC1D,IAAI,CAAC,iCAAiC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,2KAAA,CAAA,UAAO;QACnE,IAAI,CAAC,gCAAgC,GAAG,IAAI,CAAC,iCAAiC,CAAC,KAAK;QACpF,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,2KAAA,CAAA,UAAO;QACpD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK;QACtD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,+KAAA,CAAA,kBAAe;QAC5D,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,6BAA6B,CAAC,WAAW,CAAC,CAAA;YAC1D,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,WAAW,GAAG;gBAC7B,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,CAAC;YACjD;QACJ;QACA,4EAA4E;QAC5E,sHAAsH;QACtH,oEAAoE;QACpE,IAAI,CAAC,SAAS,CAAC,2KAAA,CAAA,QAAK,CAAC,MAAM,CAAC,iLAAA,CAAA,iCAA8B,CAAC,WAAW,EAAE,CAAC,IAAM,EAAE,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,GAAG;YAC1H,IAAI,CAAC,4BAA4B;QACrC;QACA,IAAI,CAAC,4BAA4B;IACrC;IACA,sBAAsB;QAClB,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,cAAc,IAAI,CAAC,gBAAgB,CAAC,eAAe,EAAE,IAAI,CAAC,UAAU,EAAE,IAAM,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc;IAC/I;IACA,yBAAyB;QACrB,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,iMAAA,CAAA,mBAAgB,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,gBAAgB,CAAC,eAAe,EAAE,IAAI,CAAC,UAAU,EAAE,IAAM,IAAI,CAAC,WAAW;IACtJ;IACA,aAAa,aAAa,EAAE;QACxB,MAAM,aAAa,IAAI,CAAC,OAAO,KAAK;QACpC,IAAI,CAAC,OAAO,EAAE;QACd,IAAI,CAAC,OAAO,GAAG,gBAAgB,IAAI,CAAC,sBAAsB,KAAK,IAAI,CAAC,mBAAmB;QACvF,IAAI,CAAC,kBAAkB,CAAC,KAAK;QAC7B,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAA;YACvD,IAAI,CAAC,4BAA4B,CAAC;QACtC;QACA,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,sCAAsC,CAAC,CAAA;YAC5E,IAAI,CAAC,0BAA0B,CAAC,0CAA0C;QAC9E;QACA,IAAI,YAAY;YACZ,wJAAwJ;YACxJ,IAAI,CAAC,OAAO,CAAC,iBAAiB;QAClC;IACJ;IACA,+BAA+B;QAC3B,IAAI,iLAAA,CAAA,iCAA8B,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,GAAG;YACtD,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,YAAY,iMAAA,CAAA,mBAAgB,GAAG;gBAC7C,IAAI,CAAC,YAAY,CAAC;YACtB;QACJ,OACK;YACD,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,YAAY,aAAa,GAAG;gBAC1C,IAAI,CAAC,YAAY,CAAC;YACtB;QACJ;IACJ;IACA,yCAAyC,CAAC,EAAE;QACxC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,WAAW,GAAG;YAC7B,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,CAAC;QACjD;IACJ;IACA,uBAAuB,CAAC,EAAE;QACtB,IAAI,EAAE,OAAO,EAAE;YACX,IAAI,CAAC,eAAe,CAAC,KAAK;QAC9B,OACK,IAAI,CAAC,EAAE,WAAW,EAAE;YACrB,KAAK,MAAM,KAAK,EAAE,OAAO,CAAE;gBACvB,MAAM,CAAC,UAAU,iBAAiB,eAAe,GAAG,CAAA,GAAA,0LAAA,CAAA,WAAQ,AAAD,EAAE,EAAE,IAAI;gBACnE,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,UAAU,iBAAiB,gBAAgB,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,iBAAiB;YACtJ;QACJ;QACA,IAAI,CAAC,OAAO,CAAC,sBAAsB,CAAC;IACxC;IACA,0BAA0B;QACtB,IAAI,CAAC,OAAO,CAAC,uBAAuB;IACxC;IACA;;KAEC,GACD,cAAc,UAAU,EAAE;QACtB,IAAI,CAAC,kBAAkB,CAAC;QACxB,MAAM,kBAAkB,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC;QACnD,OAAO,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,YAAY;IAC5D;IACA,6BAA6B,CAAC,EAAE;QAC5B,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,IAAI;YACjC,IAAI,CAAC,0BAA0B,CAAC,qBAAqB,CAAC;YACtD,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;QACjC;IACJ;IACA,yBAAyB;IACzB,mBAAmB,UAAU,EAAE;QAC3B,IAAI,aAAa,KAAK,aAAa,IAAI,CAAC,UAAU,CAAC,YAAY,IAAI;YAC/D,MAAM,IAAI,4KAAA,CAAA,qBAAkB,CAAC;QACjC;IACJ;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS;IACjC;IACA,oBAAoB;QAChB,IAAI,CAAC,OAAO,CAAC,iBAAiB;IAClC;IACA,IAAI,8BAA8B;QAC9B,OAAO,IAAI,CAAC,OAAO,CAAC,2BAA2B;IACnD;IACA,kBAAkB,UAAU,EAAE;QAC1B,IAAI,CAAC,kBAAkB,CAAC;QACxB,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;IACnC;IACA,yBAAyB,UAAU,EAAE;QACjC,IAAI,CAAC,kBAAkB,CAAC;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC,wBAAwB,CAAC;IACjD;IACA,kBAAkB,UAAU,EAAE;QAC1B,IAAI,CAAC,kBAAkB,CAAC;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;IAC1C;IACA,gBAAgB,UAAU,EAAE;QACxB,IAAI,CAAC,kBAAkB,CAAC;QACxB,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC;IACjC;IACA,iCAAiC,UAAU,EAAE,MAAM,EAAE,SAAS,EAAE;QAC5D,OAAO,IAAI,CAAC,OAAO,CAAC,gCAAgC,CAAC,YAAY,QAAQ;IAC7E;IACA,qBAAqB,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE;QAC5C,OAAO,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,UAAU,QAAQ;IAC/D;IACA,aAAa;IACb,0BAA0B;IAC1B,kBAAkB,MAAM,EAAE,UAAU,EAAE;QAClC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,QAAQ;QACjC,IAAI,CAAC,4BAA4B,CAAC;YAC9B,uBAAuB,WAAW;YAClC,QAAQ;gBAAC;oBAAE,gBAAgB;oBAAG,cAAc,IAAI,CAAC,UAAU,CAAC,YAAY;gBAAG;aAAE;QACjF;IACJ;IACA,4BAA4B;QACxB,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU;IAC1C;IACA,wBAAwB;QACpB,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO;IACxC;IACA,yBAAyB,KAAK,EAAE,MAAM,EAAE;QACpC,IAAI,IAAI,CAAC,yBAAyB,IAAI;YAClC;QACJ;QACA,MAAM,eAAe,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,OAAO;QAC1F,IAAI,CAAC,4BAA4B,CAAC;YAC9B,uBAAuB;YACvB,QAAQ;gBACJ;oBACI,gBAAgB,aAAa,eAAe;oBAC5C,cAAc,aAAa,aAAa;gBAC5C;aACH;QACL;IACJ;IACA,aAAa;IACb,0BAA0B;IAC1B,kBAAkB,SAAS,EAAE;QACzB,IAAI,CAAC,iBAAiB;QACtB,MAAM,WAAW,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC;QAClD,MAAM,cAAc,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,UAAU;QACtE,MAAM,aAAa,IAAI,CAAC,aAAa,CAAC,SAAS,UAAU;QACzD,MAAM,aAAa,WAAW,sBAAsB,CAAC,SAAS,MAAM,GAAG;QACvE,4CAA4C;QAC5C,MAAM,CAAC,eAAe,YAAY,GAAG,4BAA4B,uBAAuB,CAAC,YAAY;QACrG,MAAM,kBAAkB,CAAA,GAAA,0LAAA,CAAA,gBAAa,AAAD,EAAE,SAAS,MAAM,EAAE,IAAI,CAAC,wBAAwB,CAAC,WAAW,aAAa,CAAC,aAAa,iBAAiB,IAAI,YAAY,SAAS,CAAC,eAAe,cAAc;QACnM,+DAA+D;QAC/D,IAAI,mBACA,gBAAgB,WAAW,IAAI,UAAU,MAAM,IAC/C,UAAU,MAAM,IAAI,gBAAgB,SAAS,EAAE;YAC/C,OAAO;QACX;QACA,2EAA2E;QAC3E,IAAI,aAAa,KAAK,kBAAkB,SAAS,MAAM,GAAG,GAAG;YACzD,2FAA2F;YAC3F,MAAM,CAAC,eAAe,YAAY,GAAG,4BAA4B,uBAAuB,CAAC,YAAY,aAAa;YAClH,MAAM,iBAAiB,CAAA,GAAA,0LAAA,CAAA,gBAAa,AAAD,EAAE,SAAS,MAAM,EAAE,IAAI,CAAC,wBAAwB,CAAC,WAAW,aAAa,CAAC,aAAa,IAAI,iBAAiB,IAAI,YAAY,SAAS,CAAC,eAAe,cAAc;YACtM,+DAA+D;YAC/D,IAAI,kBACA,eAAe,WAAW,IAAI,UAAU,MAAM,IAC9C,UAAU,MAAM,IAAI,eAAe,SAAS,EAAE;gBAC9C,OAAO;YACX;QACJ;QACA,OAAO;IACX;IACA,yBAAyB,UAAU,EAAE;QACjC,OAAO,IAAI,CAAC,6BAA6B,CAAC,wBAAwB,CAAC;IACvE;IACA,OAAO,wBAAwB,UAAU,EAAE,UAAU,EAAE;QACnD,MAAM,aAAa,WAAW,aAAa,CAAC;QAC5C,4CAA4C;QAC5C,IAAI,cAAc;QAClB,IAAK,IAAI,IAAI,YAAY,KAAK,KAAK,WAAW,aAAa,CAAC,OAAO,YAAY,IAAK;YAChF,cAAc,WAAW,cAAc,CAAC;QAC5C;QACA,6CAA6C;QAC7C,IAAI,YAAY,WAAW,cAAc,GAAG,MAAM;QAClD,IAAK,IAAI,IAAI,YAAY,aAAa,WAAW,QAAQ,IAAI,IAAI,cAAc,WAAW,aAAa,CAAC,OAAO,YAAY,IAAK;YAC5H,YAAY,WAAW,YAAY,CAAC;QACxC;QACA,OAAO;YAAC;YAAa;SAAU;IACnC;IACA,qBAAqB,QAAQ,EAAE;QAC3B,MAAM,iBAAiB,IAAI,CAAC,iBAAiB,CAAC;QAC9C,IAAI,CAAC,gBAAgB;YACjB,OAAO;gBAAE,MAAM;gBAAI,aAAa,SAAS,MAAM;gBAAE,WAAW,SAAS,MAAM;YAAE;QACjF;QACA,OAAO;YACH,MAAM,eAAe,IAAI,CAAC,MAAM,CAAC,GAAG,SAAS,MAAM,GAAG,eAAe,WAAW;YAChF,aAAa,eAAe,WAAW;YACvC,WAAW,SAAS,MAAM;QAC9B;IACJ;IACA,aAAa;IACb,+BAA+B;IAC/B,gBAAgB;QACZ,OAAO,IAAI,CAAC,WAAW;IAC3B;IACA,wBAAwB,UAAU,EAAE,MAAM,EAAE;QACxC,MAAM,WAAW,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,IAAI,wLAAA,CAAA,WAAQ,CAAC,YAAY;QAC3E,MAAM,aAAa,IAAI,CAAC,aAAa,CAAC,SAAS,UAAU;QACzD,OAAO,WAAW,aAAa,CAAC,WAAW,sBAAsB,CAAC,SAAS,MAAM,GAAG;IACxF;IACA,cAAc,UAAU,EAAE,SAAS,KAAK,EAAE;QACtC,IAAI,IAAI,CAAC,WAAW,KAAK,YAAY;YACjC,wBAAwB;YACxB;QACJ;QACA,MAAM,IAAI;YACN,aAAa,IAAI,CAAC,WAAW;YAC7B,aAAa;YACb;QACJ;QACA,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,0BAA0B,CAAC,uBAAuB,CAAC;QACxD,IAAI,CAAC,OAAO,CAAC,iBAAiB;QAC9B,IAAI,CAAC,4BAA4B;QACjC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC;QAC/B,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,CAAC;IACjD;AACJ;AACA,4BAA4B,8BAA8B,WAAW;IACjE,QAAQ,GAAG,6LAAA,CAAA,mBAAgB;IAC3B,QAAQ,GAAG,kNAAA,CAAA,gCAA6B;IACxC,QAAQ,GAAG,2MAAA,CAAA,2BAAwB;CACtC,EAAE;;AAEH,MAAM,sBAAsB,uLAAA,CAAA,iBAAc;IACtC,YAAY,eAAe,EAAE,SAAS,EAAE,aAAa,EAAE,aAAa,CAAE;QAClE,KAAK,CAAC,iBAAiB,WAAW;QAClC,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,2BAA2B,GAAG;QACnC,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,+KAAA,CAAA,oBAAiB;QAChE,IAAI,CAAC,OAAO,GAAG,IAAI,uMAAA,CAAA,wBAAqB,CAAC,IAAI,CAAC,gBAAgB;QAC9D,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,+KAAA,CAAA,oBAAiB;QACrE,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,+KAAA,CAAA,gBAAa;QAC3D,IAAI,CAAC,SAAS,CAAC,iLAAA,CAAA,uBAAoB,CAAC,WAAW,CAAC,CAAC;YAC7C,MAAM,aAAa,IAAI,CAAC,aAAa;YACrC,IAAI,EAAE,gBAAgB,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG;gBAC/C;YACJ;YACA,IAAI,CAAC,iBAAiB;QAC1B;QACA,IAAI,CAAC,iBAAiB;QACtB,IAAI,CAAC,SAAS,CAAC,cAAc,wBAAwB,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;YAClE,IAAI,OAAO;gBACP,IAAI,WAAW,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC;gBAC5C,IAAI,CAAC,UAAU;oBACX,WAAW,IAAI,uLAAA,CAAA,sBAAmB,CAAC,IAAM,IAAI,CAAC,aAAa,CAAC,SAAS,UAAU;oBAC/E,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,MAAM;gBACvC;gBACA,SAAS,iBAAiB,CAAC;YAC/B,OACK;gBACD,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,CAAC;YAC9C;QACJ;IACJ;IACA,kBAAkB,uBAAuB,IAAI,EAAE;QAC3C,IAAI,CAAC,OAAO,CAAC,KAAK;QAClB,IAAI,CAAC,sBAAsB,EAAE;QAC7B,IAAI,IAAI,CAAC,sBAAsB,EAAE;YAC7B,IAAI,CAAC,sBAAsB,GAAG,IAAI,gMAAA,CAAA,iCAA8B,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY;QACjG;QACA,IAAI,sBAAsB;YACtB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBACzB,uBAAuB;gBACvB,QAAQ;oBACJ;wBACI,gBAAgB;wBAChB,cAAc,IAAI,CAAC,UAAU,CAAC,YAAY;oBAC9C;iBACH;YACL;QACJ;QACA,MAAM,yBAAyB;YAC3B,IAAI,IAAI,CAAC,UAAU,CAAC,yBAAyB,IAAI;gBAC7C,OAAO;oBAAC;oBAAM;iBAAK;YACvB;YACA,MAAM,sBAAsB,iLAAA,CAAA,uBAAoB,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa;YACvE,IAAI,CAAC,qBAAqB;gBACtB,OAAO;oBAAC;oBAAM;iBAAK;YACvB;YACA,IAAI;YACJ,IAAI;gBACA,eAAe,oBAAoB,eAAe;YACtD,EACA,OAAO,GAAG;gBACN,CAAA,GAAA,4KAAA,CAAA,oBAAiB,AAAD,EAAE;gBAClB,OAAO;oBAAC;oBAAM;iBAAK;YACvB;YACA,OAAO;gBAAC;gBAAqB;aAAa;QAC9C;QACA,MAAM,CAAC,qBAAqB,aAAa,GAAG;QAC5C,IAAI,uBAAuB,cAAc;YACrC,IAAI,CAAC,UAAU,GAAG,IAAI,gMAAA,CAAA,sCAAmC,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,IAAI,qBAAqB,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB;QACzJ,OACK;YACD,IAAI,CAAC,UAAU,GAAG;QACtB;QACA,IAAI,CAAC,oBAAoB,CAAC,KAAK;QAC/B,IAAI,CAAC,2BAA2B,GAAG;QACnC,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,MAAM,IAAI;gBACN,WAAW,CAAC;oBACR,IAAI,CAAC,SAAS,CAAC;gBACnB;gBACA,gCAAgC;oBAC5B,IAAI,IAAI,CAAC,4BAA4B,KAAK,EAAE,yCAAyC,KAAI;wBACrF,uEAAuE;wBACvE;oBACJ;oBACA,MAAM,WAAW,EAAE,yCAAyC;oBAC5D,IAAI,CAAC,4BAA4B,GAAG;oBACpC,IAAI,CAAC,uCAAuC,CAAC,IAAI;gBACrD;gBACA,aAAa,CAAC,YAAY;oBACtB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;wBAClB;oBACJ;oBACA,MAAM,iCAAiC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,iCAAiC;oBAC9F,wFAAwF;oBACxF,IAAI,mCAAmC,QAAQ,cAAc,gCAAgC;wBACzF,IAAI,CAAC,UAAU,EAAE,MAAM,YAAY,YAAY;oBACnD;gBACJ;YACJ;YACA,IAAI,uBAAuB,oBAAoB,yBAAyB,IAAI,CAAC,oBAAoB,yCAAyC,EAAE;gBACxI,IAAI,CAAC,oBAAoB,CAAC,KAAK,GAAG,oBAAoB,yBAAyB,CAAC,IAAI,CAAC,UAAU,EAAE;YACrG;YACA,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,yBAAyB,IAAI;gBAClF,IAAI,CAAC,oBAAoB,CAAC,KAAK,GAAG,IAAI,CAAC,2BAA2B,GAC9D,IAAI,gMAAA,CAAA,6BAA0B,CAAC,IAAI,CAAC,UAAU,EAAE;gBACpD,IAAI,CAAC,2BAA2B,CAAC,aAAa;YAClD;YACA,IAAI,qBAAqB,6CAA6C,oBAAoB,yBAAyB,EAAE;gBACjH,IAAI,CAAC,sBAAsB,GAAG,IAAI,uMAAA,CAAA,wBAAqB,CAAC,IAAI,CAAC,gBAAgB;gBAC7E,IAAI,CAAC,sBAAsB,GAAG,IAAI,gMAAA,CAAA,iCAA8B,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY;gBAC7F,IAAI,CAAC,yBAAyB,CAAC,KAAK;gBACpC,IAAI,CAAC,yBAAyB,CAAC,KAAK,GAAG,oBAAoB,yBAAyB,CAAC,IAAI,CAAC,UAAU,EAAE;oBAClG,WAAW,CAAC;wBACR,IAAI,CAAC,sBAAsB,EAAE,mBAAmB,QAAQ,IAAI,CAAC,UAAU;oBAC3E;oBACA;oBACI,QAAQ;oBACZ;oBACA,aAAa,CAAC,YAAY;wBACtB,IAAI,CAAC,sBAAsB,EAAE,YAAY,YAAY;oBACzD;gBACJ;YACJ,OACK;gBACD,IAAI,CAAC,sBAAsB,GAAG;gBAC9B,IAAI,CAAC,sBAAsB,GAAG;gBAC9B,IAAI,CAAC,yBAAyB,CAAC,KAAK,GAAG;YAC3C;QACJ;QACA,IAAI,CAAC,2BAA2B;IACpC;IACA,0BAA0B;QACtB,IAAI,CAAC,2BAA2B,EAAE;IACtC;IACA,uBAAuB,CAAC,EAAE;QACtB,IAAI,EAAE,OAAO,EAAE;YACX,iFAAiF;YACjF,IAAI,CAAC,iBAAiB,CAAC;QAC3B,OACK,IAAI,CAAC,EAAE,WAAW,EAAE;YACrB,KAAK,MAAM,KAAK,EAAE,OAAO,CAAE;gBACvB,MAAM,CAAC,UAAU,gBAAgB,GAAG,CAAA,GAAA,0LAAA,CAAA,WAAQ,AAAD,EAAE,EAAE,IAAI;gBACnD,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,UAAU;gBAC3C,IAAI,CAAC,sBAAsB,EAAE,WAAW,EAAE,KAAK,EAAE,UAAU;YAC/D;YACA,IAAI,CAAC,sBAAsB,EAAE,cAAc,EAAE,OAAO;YACpD,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,OAAO;YACjD;YACA,IAAI,CAAC,2BAA2B,EAAE;QACtC;IACJ;IACA,UAAU,MAAM,EAAE;QACd,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,QAAQ,IAAI,CAAC,UAAU;QAC3E,IAAI,QAAQ,MAAM,GAAG,GAAG;YACpB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBAAE,uBAAuB;gBAAO,QAAQ;YAAS;QAClF;QACA,OAAO;YAAE,SAAS;QAAQ;IAC9B;IACA,8BAA8B;QAC1B,MAAM,SAAS,yLAAA,CAAA,YAAS,CAAC,QAAQ,CAAC;eAAI,IAAI,CAAC,mBAAmB;SAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK,EAAE,UAAU;QAC5F,IAAI,CAAC,aAAa,CAAC;IACvB;IACA,cAAc,MAAM,EAAE;QAClB,KAAK,MAAM,SAAS,OAAQ;YACxB,IAAI,CAAC,YAAY,CAAC,MAAM,eAAe,EAAE,MAAM,sBAAsB,GAAG;QAC5E;IACJ;IACA,aAAa,eAAe,EAAE,aAAa,EAAE;QACzC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB;QACJ;QACA,kBAAkB,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,IAAI;QACvE,gBAAgB,KAAK,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,IAAI;QACzD,MAAM,UAAU,IAAI,kNAAA,CAAA,mCAAgC;QACpD,MAAM,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,SAAS,iBAAiB;QAC5F,MAAM,gBAAgB,IAAI,CAAC,SAAS,CAAC,QAAQ,QAAQ;QACrD,IAAI,iBAAiB;YACjB,uDAAuD;YACvD,oEAAoE;YACpE,yEAAyE;YACzE,KAAK,MAAM,KAAK,cAAc,OAAO,CAAE;gBACnC,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,cAAc,EAAE,cAAc,EAAE,EAAE,YAAY,GAAG;YACtF;QACJ;QACA,IAAI,CAAC,2BAA2B,EAAE;IACtC;IACA,kBAAkB,UAAU,EAAE;QAC1B,MAAM,UAAU,IAAI,kNAAA,CAAA,mCAAgC;QACpD,IAAI,CAAC,UAAU,EAAE,sBAAsB,SAAS;QAChD,IAAI,CAAC,SAAS,CAAC,QAAQ,QAAQ;QAC/B,IAAI,CAAC,2BAA2B,EAAE;IACtC;IACA,yBAAyB,UAAU,EAAE;QACjC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,OAAO;QACX;QACA,OAAO,IAAI,CAAC,UAAU,CAAC,wBAAwB,CAAC;IACpD;IACA,kBAAkB,UAAU,EAAE;QAC1B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,OAAO;QACX;QACA,OAAO,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC;IAC7C;IACA,cAAc,UAAU,EAAE;QACtB,MAAM,WAAW,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;QAChD,MAAM,SAAS,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,IAAI,aAAa,GAAG;QACvF,IAAI,IAAI,CAAC,sBAAsB,IAAI,IAAI,CAAC,sBAAsB,IAAI,IAAI,CAAC,UAAU,EAAE;YAC/E,IAAI,IAAI,CAAC,sBAAsB,CAAC,sCAAsC,KAAK,cAAc,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,sCAAsC,KAAK,YAAY;gBAClK,MAAM,mBAAmB,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,IAAI,aAAa,GAAG;gBAChH,IAAI,CAAC,OAAO,MAAM,CAAC,qBAAqB,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,yBAAyB;oBACnG,IAAI,CAAC,yBAAyB,CAAC,KAAK,CAAC,uBAAuB,CAAC;gBACjE;YACJ;QACJ;QACA,OAAO;IACX;IACA,iCAAiC,UAAU,EAAE,MAAM,EAAE,SAAS,EAAE;QAC5D,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,OAAO,EAAE,2BAA2B;QACxC;QACA,MAAM,WAAW,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,IAAI,wLAAA,CAAA,WAAQ,CAAC,YAAY;QAC3E,IAAI,CAAC,iBAAiB,CAAC,SAAS,UAAU;QAC1C,OAAO,IAAI,CAAC,UAAU,CAAC,gCAAgC,CAAC,UAAU;IACtE;IACA,qBAAqB,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE;QAC5C,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,OAAO;QACX;QACA,MAAM,oBAAoB,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC;QAC3D,IAAI,CAAC,iBAAiB,CAAC,kBAAkB,UAAU;QACnD,OAAO,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,mBAAmB,QAAQ;IAC3E;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS;IACjC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9534, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11492, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/textModelText.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { AbstractText } from '../core/textEdit.js';\nimport { TextLength } from '../core/textLength.js';\nexport class TextModelText extends AbstractText {\n    constructor(_textModel) {\n        super();\n        this._textModel = _textModel;\n    }\n    getValueOfRange(range) {\n        return this._textModel.getValueInRange(range);\n    }\n    get length() {\n        const lastLineNumber = this._textModel.getLineCount();\n        const lastLineLen = this._textModel.getLineLength(lastLineNumber);\n        return new TextLength(lastLineNumber - 1, lastLineLen);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;;;AACO,MAAM,sBAAsB,wLAAA,CAAA,eAAY;IAC3C,YAAY,UAAU,CAAE;QACpB,KAAK;QACL,IAAI,CAAC,UAAU,GAAG;IACtB;IACA,gBAAgB,KAAK,EAAE;QACnB,OAAO,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC;IAC3C;IACA,IAAI,SAAS;QACT,MAAM,iBAAiB,IAAI,CAAC,UAAU,CAAC,YAAY;QACnD,MAAM,cAAc,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;QAClD,OAAO,IAAI,0LAAA,CAAA,aAAU,CAAC,iBAAiB,GAAG;IAC9C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11522, "column": 0}, "map": {"version":3,"sources":["file:///Users/oscarthroedsson/Documents/code/myownprojects/JSONFloat/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;8FAG8F;;;AAC9F;AACA;AACA;AACA;AACA;;;;;;AACO,SAAS,kBAAkB,MAAM,EAAE,4BAA4B;IAClE,MAAM,mBAAmB,IAAI,mPAAA,CAAA,mBAAgB;IAC7C,MAAM,gBAAgB,IAAI,0OAAA,CAAA,gCAA6B,CAAC,kBAAkB,CAAC,aAAe,6BAA6B,wBAAwB,CAAC;IAChJ,MAAM,YAAY,IAAI,2OAAA,CAAA,sBAAmB,CAAC,IAAI,sBAAsB;QAAC;KAAO,GAAG;IAC/E,MAAM,OAAO,CAAA,GAAA,wOAAA,CAAA,gBAAa,AAAD,EAAE,WAAW,EAAE,EAAE,WAAW;IACrD,IAAI,MAAM;IACV,MAAM,OAAO,OAAO,cAAc;IAClC,SAAS,YAAY,IAAI,EAAE,MAAM;QAC7B,IAAI,KAAK,IAAI,KAAK,EAAE,oBAAoB,KAAI;YACxC,YAAY,KAAK,cAAc,EAAE;YACjC,SAAS,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,QAAQ,KAAK,cAAc,CAAC,MAAM;YACrD,IAAI,KAAK,KAAK,EAAE;gBACZ,YAAY,KAAK,KAAK,EAAE;gBACxB,SAAS,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,QAAQ,KAAK,KAAK,CAAC,MAAM;YAChD;YACA,IAAI,KAAK,cAAc,EAAE;gBACrB,YAAY,KAAK,cAAc,EAAE;gBACjC,SAAS,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,QAAQ,KAAK,cAAc,CAAC,MAAM;YACzD,OACK;gBACD,MAAM,0BAA0B,cAAc,8BAA8B,CAAC,KAAK,cAAc,CAAC,UAAU;gBAC3G,MAAM,mBAAmB,wBAAwB,oBAAoB,CAAC,KAAK,cAAc,CAAC,UAAU;gBACpG,OAAO;YACX;QACJ,OACK,IAAI,KAAK,IAAI,KAAK,EAAE,wCAAwC,KAAI;QACjE,qBAAqB;QACzB,OACK,IAAI,KAAK,IAAI,KAAK,EAAE,oBAAoB,OAAM,KAAK,IAAI,KAAK,EAAE,uBAAuB,KAAI;YAC1F,OAAO,KAAK,SAAS,CAAC,CAAA,GAAA,wOAAA,CAAA,sCAAmC,AAAD,EAAE,SAAS,CAAA,GAAA,wOAAA,CAAA,sCAAmC,AAAD,EAAE,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,QAAQ,KAAK,MAAM;QACxI,OACK,IAAI,KAAK,IAAI,KAAK,EAAE,oBAAoB,KAAI;YAC7C,KAAK,MAAM,SAAS,KAAK,QAAQ,CAAE;gBAC/B,YAAY,OAAO;gBACnB,SAAS,CAAA,GAAA,wOAAA,CAAA,YAAS,AAAD,EAAE,QAAQ,MAAM,MAAM;YAC3C;QACJ;IACJ;IACA,YAAY,MAAM,wOAAA,CAAA,aAAU;IAC5B,OAAO;AACX;AACA,MAAM;IACF,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,YAAY,GAAG;YAChB,eAAe,CAAC;gBACZ,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE;YACrC;QACJ;IACJ;IACA,eAAe;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM;IAC5B;IACA,cAAc,UAAU,EAAE;QACtB,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE,CAAC,cAAc,GAAG,MAAM;IAC7D;AACJ","ignoreList":[0],"debugId":null}}]
}