(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/kld-intersections/lib/PathHandler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 *  PathHandler.js
 *
 *  @copyright 2017 Kevin Lindsey
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Point2D.js [app-client] (ecmascript) <export default as Point2D>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Vector2D.js [app-client] (ecmascript) <export default as Vector2D>");
;
const TWO_PI = 2.0 * Math.PI;
/**
 * Based on the SVG 1.1 specification, Appendix F: Implementation Requirements,
 * Section F.6 "Elliptical arc implementation notes"
 * {@see https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes}
 *
 * @param {module:kld-affine.Point2D} startPoint
 * @param {module:kld-affine.Point2D} endPoint
 * @param {number} rx
 * @param {number} ry
 * @param {number} angle
 * @param {boolean} arcFlag
 * @param {boolean} sweepFlag
 * @returns {Array}
 */ function getArcParameters(startPoint, endPoint, rx, ry, angle, arcFlag, sweepFlag) {
    angle = angle * Math.PI / 180;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const TOLERANCE = 1e-6;
    // Section (F.6.5.1)
    const halfDiff = startPoint.subtract(endPoint).multiply(0.5);
    const x1p = halfDiff.x * c + halfDiff.y * s;
    const y1p = halfDiff.x * -s + halfDiff.y * c;
    // Section (F.6.6.1)
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    // Section (F.6.6.2)
    const x1px1p = x1p * x1p;
    const y1py1p = y1p * y1p;
    const lambda = x1px1p / (rx * rx) + y1py1p / (ry * ry);
    // Section (F.6.6.3)
    if (lambda > 1) {
        const factor = Math.sqrt(lambda);
        rx *= factor;
        ry *= factor;
    }
    // Section (F.6.5.2)
    const rxrx = rx * rx;
    const ryry = ry * ry;
    const rxy1 = rxrx * y1py1p;
    const ryx1 = ryry * x1px1p;
    let factor = (rxrx * ryry - rxy1 - ryx1) / (rxy1 + ryx1);
    if (Math.abs(factor) < TOLERANCE) {
        factor = 0;
    }
    let sq = Math.sqrt(factor);
    if (arcFlag === sweepFlag) {
        sq = -sq;
    }
    // Section (F.6.5.3)
    const mid = startPoint.add(endPoint).multiply(0.5);
    const cxp = sq * rx * y1p / ry;
    const cyp = sq * -ry * x1p / rx;
    // Section (F.6.5.5 - F.6.5.6)
    const xcr1 = (x1p - cxp) / rx;
    const xcr2 = (x1p + cxp) / rx;
    const ycr1 = (y1p - cyp) / ry;
    const ycr2 = (y1p + cyp) / ry;
    const theta1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](1, 0).angleBetween(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](xcr1, ycr1));
    // let deltaTheta = normalizeAngle(new Vector2D(xcr1, ycr1).angleBetween(new Vector2D(-xcr2, -ycr2)));
    let deltaTheta = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](xcr1, ycr1).angleBetween(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](-xcr2, -ycr2));
    if (sweepFlag === false) {
        deltaTheta -= TWO_PI;
    }
    return [
        cxp * c - cyp * s + mid.x,
        cxp * s + cyp * c + mid.y,
        rx,
        ry,
        theta1,
        theta1 + deltaTheta
    ];
}
/**
 *  PathHandler
 */ class PathHandler {
    /**
     * PathHandler
     *
     * @param {ShapeInfo} shapeCreator
     */ constructor(shapeCreator){
        this.shapeCreator = shapeCreator;
        this.shapes = [];
        this.firstX = null;
        this.firstY = null;
        this.lastX = null;
        this.lastY = null;
        this.lastCommand = null;
    }
    /**
     * beginParse
     */ beginParse() {
        // zero out the sub-path array
        this.shapes = [];
        // clear firstX, firstY, lastX, and lastY
        this.firstX = null;
        this.firstY = null;
        this.lastX = null;
        this.lastY = null;
        // need to remember last command type to determine how to handle the
        // relative Bezier commands
        this.lastCommand = null;
    }
    /**
     *  addShape
     *
     *  @param {ShapeInfo} shape
     */ addShape(shape) {
        this.shapes.push(shape);
    }
    /**
     *  arcAbs - A
     *
     *  @param {number} rx
     *  @param {number} ry
     *  @param {number} xAxisRotation
     *  @param {boolean} arcFlag
     *  @param {boolean} sweepFlag
     *  @param {number} x
     *  @param {number} y
     */ arcAbs(rx, ry, xAxisRotation, arcFlag, sweepFlag, x, y) {
        if (rx === 0 || ry === 0) {
            this.addShape(this.shapeCreator.line(this.lastX, this.lastY, x, y));
        } else {
            const arcParameters = getArcParameters(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](this.lastX, this.lastY), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](x, y), rx, ry, xAxisRotation, arcFlag, sweepFlag);
            this.addShape(this.shapeCreator.arc(...arcParameters));
        }
        this.lastCommand = "A";
        this.lastX = x;
        this.lastY = y;
    }
    /**
     *  arcRel - a
     *
     *  @param {number} rx
     *  @param {number} ry
     *  @param {number} xAxisRotation
     *  @param {boolean} arcFlag
     *  @param {boolean} sweepFlag
     *  @param {number} x
     *  @param {number} y
     */ arcRel(rx, ry, xAxisRotation, arcFlag, sweepFlag, x, y) {
        if (rx === 0 || ry === 0) {
            this.addShape(this.shapeCreator.line(this.lastX, this.lastY, this.lastX + x, this.lastY + y));
        } else {
            const arcParameters = getArcParameters(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](this.lastX, this.lastY), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](this.lastX + x, this.lastY + y), rx, ry, xAxisRotation, arcFlag, sweepFlag);
            this.addShape(this.shapeCreator.arc(...arcParameters));
        }
        this.lastCommand = "a";
        this.lastX += x;
        this.lastY += y;
    }
    /**
     *  curvetoCubicAbs - C
     *
     *  @param {number} x1
     *  @param {number} y1
     *  @param {number} x2
     *  @param {number} y2
     *  @param {number} x
     *  @param {number} y
     */ curvetoCubicAbs(x1, y1, x2, y2, x, y) {
        this.addShape(this.shapeCreator.cubicBezier(this.lastX, this.lastY, x1, y1, x2, y2, x, y));
        this.lastX = x;
        this.lastY = y;
        this.lastCommand = "C";
    }
    /**
     *  curvetoCubicRel - c
     *
     *  @param {number} x1
     *  @param {number} y1
     *  @param {number} x2
     *  @param {number} y2
     *  @param {number} x
     *  @param {number} y
     */ curvetoCubicRel(x1, y1, x2, y2, x, y) {
        this.addShape(this.shapeCreator.cubicBezier(this.lastX, this.lastY, this.lastX + x1, this.lastY + y1, this.lastX + x2, this.lastY + y2, this.lastX + x, this.lastY + y));
        this.lastX += x;
        this.lastY += y;
        this.lastCommand = "c";
    }
    /**
     *  linetoHorizontalAbs - H
     *
     *  @param {number} x
     */ linetoHorizontalAbs(x) {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, x, this.lastY));
        this.lastX = x;
        this.lastCommand = "H";
    }
    /**
     *  linetoHorizontalRel - h
     *
     *  @param {number} x
     */ linetoHorizontalRel(x) {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, this.lastX + x, this.lastY));
        this.lastX += x;
        this.lastCommand = "h";
    }
    /**
     *  linetoAbs - L
     *
     *  @param {number} x
     *  @param {number} y
     */ linetoAbs(x, y) {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, x, y));
        this.lastX = x;
        this.lastY = y;
        this.lastCommand = "L";
    }
    /**
     *  linetoRel - l
     *
     *  @param {number} x
     *  @param {number} y
     */ linetoRel(x, y) {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, this.lastX + x, this.lastY + y));
        this.lastX += x;
        this.lastY += y;
        this.lastCommand = "l";
    }
    /**
     *  movetoAbs - M
     *
     *  @param {number} x
     *  @param {number} y
     */ movetoAbs(x, y) {
        this.firstX = x;
        this.firstY = y;
        this.lastX = x;
        this.lastY = y;
        this.lastCommand = "M";
    }
    /**
     *  movetoRel - m
     *
     *  @param {number} x
     *  @param {number} y
     */ movetoRel(x, y) {
        this.firstX += x;
        this.firstY += y;
        this.lastX += x;
        this.lastY += y;
        this.lastCommand = "m";
    }
    /**
     *  curvetoQuadraticAbs - Q
     *
     *  @param {number} x1
     *  @param {number} y1
     *  @param {number} x
     *  @param {number} y
     */ curvetoQuadraticAbs(x1, y1, x, y) {
        this.addShape(this.shapeCreator.quadraticBezier(this.lastX, this.lastY, x1, y1, x, y));
        this.lastX = x;
        this.lastY = y;
        this.lastCommand = "Q";
    }
    /**
     *  curvetoQuadraticRel - q
     *
     *  @param {number} x1
     *  @param {number} y1
     *  @param {number} x
     *  @param {number} y
     */ curvetoQuadraticRel(x1, y1, x, y) {
        this.addShape(this.shapeCreator.quadraticBezier(this.lastX, this.lastY, this.lastX + x1, this.lastY + y1, this.lastX + x, this.lastY + y));
        this.lastX += x;
        this.lastY += y;
        this.lastCommand = "q";
    }
    /**
     *  curvetoCubicSmoothAbs - S
     *
     *  @param {number} x2
     *  @param {number} y2
     *  @param {number} x
     *  @param {number} y
     */ curvetoCubicSmoothAbs(x2, y2, x, y) {
        let controlX, controlY;
        if (this.lastCommand.match(/^[SsCc]$/)) {
            const secondToLast = this.shapes[this.shapes.length - 1].args[2];
            controlX = 2 * this.lastX - secondToLast.x;
            controlY = 2 * this.lastY - secondToLast.y;
        } else {
            controlX = this.lastX;
            controlY = this.lastY;
        }
        this.addShape(this.shapeCreator.cubicBezier(this.lastX, this.lastY, controlX, controlY, x2, y2, x, y));
        this.lastX = x;
        this.lastY = y;
        this.lastCommand = "S";
    }
    /**
     *  curvetoCubicSmoothRel - s
     *
     *  @param {number} x2
     *  @param {number} y2
     *  @param {number} x
     *  @param {number} y
     */ curvetoCubicSmoothRel(x2, y2, x, y) {
        let controlX, controlY;
        if (this.lastCommand.match(/^[SsCc]$/)) {
            const secondToLast = this.shapes[this.shapes.length - 1].args[2];
            controlX = 2 * this.lastX - secondToLast.x;
            controlY = 2 * this.lastY - secondToLast.y;
        } else {
            controlX = this.lastX;
            controlY = this.lastY;
        }
        this.addShape(this.shapeCreator.cubicBezier(this.lastX, this.lastY, controlX, controlY, this.lastX + x2, this.lastY + y2, this.lastX + x, this.lastY + y));
        this.lastX += x;
        this.lastY += y;
        this.lastCommand = "s";
    }
    /**
     *  curvetoQuadraticSmoothAbs - T
     *
     *  @param {number} x
     *  @param {number} y
     */ curvetoQuadraticSmoothAbs(x, y) {
        let controlX, controlY;
        if (this.lastCommand.match(/^[QqTt]$/)) {
            const secondToLast = this.shapes[this.shapes.length - 1].args[1];
            controlX = 2 * this.lastX - secondToLast.x;
            controlY = 2 * this.lastY - secondToLast.y;
        } else {
            controlX = this.lastX;
            controlY = this.lastY;
        }
        this.addShape(this.shapeCreator.quadraticBezier(this.lastX, this.lastY, controlX, controlY, x, y));
        this.lastX = x;
        this.lastY = y;
        this.lastCommand = "T";
    }
    /**
     *  curvetoQuadraticSmoothRel - t
     *
     *  @param {number} x
     *  @param {number} y
     */ curvetoQuadraticSmoothRel(x, y) {
        let controlX, controlY;
        if (this.lastCommand.match(/^[QqTt]$/)) {
            const secondToLast = this.shapes[this.shapes.length - 1].args[1];
            controlX = 2 * this.lastX - secondToLast.x;
            controlY = 2 * this.lastY - secondToLast.y;
        } else {
            controlX = this.lastX;
            controlY = this.lastY;
        }
        this.addShape(this.shapeCreator.quadraticBezier(this.lastX, this.lastY, controlX, controlY, this.lastX + x, this.lastY + y));
        this.lastX += x;
        this.lastY += y;
        this.lastCommand = "t";
    }
    /**
     *  linetoVerticalAbs - V
     *
     *  @param {number} y
     */ linetoVerticalAbs(y) {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, this.lastX, y));
        this.lastY = y;
        this.lastCommand = "V";
    }
    /**
     *  linetoVerticalRel - v
     *
     *  @param {number} y
     */ linetoVerticalRel(y) {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, this.lastX, this.lastY + y));
        this.lastY += y;
        this.lastCommand = "v";
    }
    /**
     *  closePath - z or Z
     */ closePath() {
        this.addShape(this.shapeCreator.line(this.lastX, this.lastY, this.firstX, this.firstY));
        this.lastX = this.firstX;
        this.lastY = this.firstY;
        this.lastCommand = "z";
    }
}
const __TURBOPACK__default__export__ = PathHandler;
}}),
"[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 *  ShapeInfo.js
 *  @copyright 2002, 2017 Kevin Lindsey
 */ __turbopack_context__.s({
    "default": (()=>ShapeInfo),
    "getValues": (()=>getValues),
    "parseNumber": (()=>parseNumber),
    "parsePoint": (()=>parsePoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Point2D.js [app-client] (ecmascript) <export default as Point2D>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$path$2d$parser$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-path-parser/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$path$2d$parser$2f$lib$2f$PathParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PathParser$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-path-parser/lib/PathParser.js [app-client] (ecmascript) <export default as PathParser>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$PathHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/PathHandler.js [app-client] (ecmascript)");
;
;
;
const degree90 = Math.PI * 0.5;
const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$path$2d$parser$2f$lib$2f$PathParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__PathParser$3e$__["PathParser"]();
function getValues(types, args) {
    const result = [];
    for (const [names, type] of types){
        let value = null;
        if (type === "Point2D") {
            value = parsePoint(names, args);
        } else if (type === "Number") {
            value = parseNumber(names, args);
        } else if (type === "Array<Point2D>" || type === "Point2D[]") {
            const values = [];
            while(args.length > 0){
                values.push(parsePoint(names, args));
            }
            if (values.length > 0) {
                value = values;
            }
        } else if (type === "Optional<Number>" || type === "Number?") {
            value = parseNumber(names, args);
            if (value === null) {
                value = undefined;
            }
        } else {
            throw new TypeError(`Unrecognized value type: ${type}`);
        }
        if (value !== null) {
            result.push(value);
        } else {
            throw new TypeError(`Unable to extract value for ${names}`);
        }
    }
    return result;
}
function parseNumber(names, args) {
    let result = null;
    if (args.length > 0) {
        const item = args[0];
        const itemType = typeof item;
        if (itemType === "number") {
            return args.shift();
        } else if (itemType === "object") {
            for (const prop of names){
                if (prop in item && typeof item[prop] === "number") {
                    result = item[prop];
                    break;
                }
            }
        }
    }
    return result;
}
function parsePoint(names, args) {
    let result = null;
    if (args.length > 0) {
        const item = args[0];
        const itemType = typeof item;
        if (itemType === "number") {
            if (args.length > 1) {
                const x = args.shift();
                const y = args.shift();
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](x, y);
            }
        } else if (Array.isArray(item) && item.length > 1) {
            if (item.length === 2) {
                const [x, y] = args.shift();
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](x, y);
            } else {
                throw new TypeError(`Unhandled array of length ${item.length}`);
            }
        } else if (itemType === "object") {
            if ("x" in item && "y" in item) {
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](item.x, item.y);
                args.shift();
            } else {
                for (const props of names){
                    if (Array.isArray(props)) {
                        if (props.every((p)=>p in item)) {
                            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](item[props[0]], item[props[1]]);
                            break;
                        }
                    } else if (props in item) {
                        result = parsePoint([], [
                            item[props]
                        ]);
                        break;
                    }
                }
            }
        }
    }
    return result;
}
class ShapeInfo {
    /**
     *  @param {string} name
     *  @param {Array} args
     *  @returns {module:kld-intersections.ShapeInfo}
     */ constructor(name, args){
        this.name = name;
        this.args = args;
    }
    static arc(...args) {
        const types = [
            [
                [
                    "center",
                    [
                        "centerX",
                        "centerY"
                    ],
                    [
                        "cx",
                        "cy"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "radiusX",
                    "rx"
                ],
                "Number"
            ],
            [
                [
                    "radiusY",
                    "ry"
                ],
                "Number"
            ],
            [
                [
                    "startRadians"
                ],
                "Number"
            ],
            [
                [
                    "endRadians"
                ],
                "Number"
            ]
        ];
        const values = getValues(types, args);
        return new ShapeInfo(ShapeInfo.ARC, values);
    }
    static quadraticBezier(...args) {
        const types = [
            [
                [
                    "p1",
                    [
                        "p1x",
                        "p1y"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "p2",
                    [
                        "p2x",
                        "p2y"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "p3",
                    [
                        "p3x",
                        "p3y"
                    ]
                ],
                "Point2D"
            ]
        ];
        const values = getValues(types, args);
        return new ShapeInfo(ShapeInfo.QUADRATIC_BEZIER, values);
    }
    static cubicBezier(...args) {
        const types = [
            [
                [
                    "p1",
                    [
                        "p1x",
                        "p1y"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "p2",
                    [
                        "p2x",
                        "p2y"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "p3",
                    [
                        "p3x",
                        "p3y"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "p4",
                    [
                        "p4x",
                        "p4y"
                    ]
                ],
                "Point2D"
            ]
        ];
        const values = getValues(types, args);
        return new ShapeInfo(ShapeInfo.CUBIC_BEZIER, values);
    }
    static circle(...args) {
        const types = [
            [
                [
                    "center",
                    [
                        "centerX",
                        "centerY"
                    ],
                    [
                        "cx",
                        "cy"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "radius",
                    "r"
                ],
                "Number"
            ]
        ];
        const values = getValues(types, args);
        return new ShapeInfo(ShapeInfo.CIRCLE, values);
    }
    static ellipse(...args) {
        const types = [
            [
                [
                    "center",
                    [
                        "centerX",
                        "centerY"
                    ],
                    [
                        "cx",
                        "cy"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "radiusX",
                    "rx"
                ],
                "Number"
            ],
            [
                [
                    "radiusY",
                    "ry"
                ],
                "Number"
            ]
        ];
        const values = getValues(types, args);
        return new ShapeInfo(ShapeInfo.ELLIPSE, values);
    }
    static line(...args) {
        const types = [
            [
                [
                    "p1",
                    [
                        "p1x",
                        "p1y"
                    ],
                    [
                        "x1",
                        "y1"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "p2",
                    [
                        "p2x",
                        "p2y"
                    ],
                    [
                        "x2",
                        "y2"
                    ]
                ],
                "Point2D"
            ]
        ];
        const values = getValues(types, args);
        return new ShapeInfo(ShapeInfo.LINE, values);
    }
    static path(...args) {
        parser.parseData(args[0]);
        return new ShapeInfo(ShapeInfo.PATH, handler.shapes);
    }
    static polygon(...args) {
        const types = [
            [
                [],
                "Array<Point2D>"
            ]
        ];
        const values = getValues(types, args.length === 1 && Array.isArray(args[0]) ? args[0] : args);
        return new ShapeInfo(ShapeInfo.POLYGON, values);
    }
    static polyline(...args) {
        const types = [
            [
                [],
                "Array<Point2D>"
            ]
        ];
        const values = getValues(types, args.length === 1 && Array.isArray(args[0]) ? args[0] : args);
        return new ShapeInfo(ShapeInfo.POLYLINE, values);
    }
    static rectangle(...args) {
        const types = [
            [
                [
                    "topLeft",
                    [
                        "x",
                        "y"
                    ],
                    [
                        "left",
                        "top"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "size",
                    [
                        "width",
                        "height"
                    ],
                    [
                        "w",
                        "h"
                    ]
                ],
                "Point2D"
            ],
            [
                [
                    "radiusX",
                    "rx"
                ],
                "Optional<Number>"
            ],
            [
                [
                    "radiusY",
                    "ry"
                ],
                "Optional<Number>"
            ]
        ];
        const values = getValues(types, args);
        // fix up bottom-right point
        const p1 = values[0];
        const p2 = values[1];
        values[1] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](p1.x + p2.x, p1.y + p2.y);
        // create shape info
        const result = new ShapeInfo(ShapeInfo.RECTANGLE, values);
        // handle possible rounded rectangle values
        let ry = result.args.pop();
        let rx = result.args.pop();
        rx = rx === undefined ? 0 : rx;
        ry = ry === undefined ? 0 : ry;
        if (rx === 0 && ry === 0) {
            return result;
        }
        const { x: p1x, y: p1y } = result.args[0];
        const { x: p2x, y: p2y } = result.args[1];
        const width = p2x - p1x;
        const height = p2y - p1y;
        if (rx === 0) {
            rx = ry;
        }
        if (ry === 0) {
            ry = rx;
        }
        if (rx > width * 0.5) {
            rx = width * 0.5;
        }
        if (ry > height * 0.5) {
            ry = height * 0.5;
        }
        const x0 = p1x;
        const y0 = p1y;
        const x1 = p1x + rx;
        const y1 = p1y + ry;
        const x2 = p2x - rx;
        const y2 = p2y - ry;
        const x3 = p2x;
        const y3 = p2y;
        const segments = [
            ShapeInfo.arc(x1, y1, rx, ry, 2 * degree90, 3 * degree90),
            ShapeInfo.line(x1, y0, x2, y0),
            ShapeInfo.arc(x2, y1, rx, ry, 3 * degree90, 4 * degree90),
            ShapeInfo.line(x3, y1, x3, y2),
            ShapeInfo.arc(x2, y2, rx, ry, 0, degree90),
            ShapeInfo.line(x2, y3, x1, y3),
            ShapeInfo.arc(x1, y2, rx, ry, degree90, 2 * degree90),
            ShapeInfo.line(x0, y2, x0, y1)
        ];
        return new ShapeInfo(ShapeInfo.PATH, segments);
    }
}
// define shape name constants
ShapeInfo.ARC = "Arc";
ShapeInfo.QUADRATIC_BEZIER = "Bezier2";
ShapeInfo.CUBIC_BEZIER = "Bezier3";
ShapeInfo.CIRCLE = "Circle";
ShapeInfo.ELLIPSE = "Ellipse";
ShapeInfo.LINE = "Line";
ShapeInfo.PATH = "Path";
ShapeInfo.POLYGON = "Polygon";
ShapeInfo.POLYLINE = "Polyline";
ShapeInfo.RECTANGLE = "Rectangle";
// setup path parser handler after ShapeInfo has been defined
const handler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$PathHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](ShapeInfo);
parser.setHandler(handler);
}}),
"[project]/node_modules/kld-intersections/lib/Intersection.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable camelcase, no-labels */ /**
 *
 *  Intersection.js
 *
 *  copyright 2002, 2013 Kevin Lindsey
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Point2D.js [app-client] (ecmascript) <export default as Point2D>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Vector2D.js [app-client] (ecmascript) <export default as Vector2D>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-polynomial/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-polynomial/lib/Polynomial.js [app-client] (ecmascript) <export default as Polynomial>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)");
;
;
;
const TWO_PI = 2.0 * Math.PI;
const UNIT_X = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](1, 0);
/**
 * @memberof module:kld-intersections.Intersection
 * @param {*} o
 * @returns {boolean}
 */ function isNullish(o) {
    return o === null || o === undefined;
}
/**
 *  bezout
 *
 *  This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His
 *  code along with many other excellent examples are avaiable at his site:
 *  http://www.magic-software.com
 *
 *  @param {Array<module:kld-intersections.Point2D>} e1
 *  @param {Array<module:kld-intersections.Point2D>} e2
 *  @returns {external:Polynomial}
 */ function bezout(e1, e2) {
    const AB = e1[0] * e2[1] - e2[0] * e1[1];
    const AC = e1[0] * e2[2] - e2[0] * e1[2];
    const AD = e1[0] * e2[3] - e2[0] * e1[3];
    const AE = e1[0] * e2[4] - e2[0] * e1[4];
    const AF = e1[0] * e2[5] - e2[0] * e1[5];
    const BC = e1[1] * e2[2] - e2[1] * e1[2];
    const BE = e1[1] * e2[4] - e2[1] * e1[4];
    const BF = e1[1] * e2[5] - e2[1] * e1[5];
    const CD = e1[2] * e2[3] - e2[2] * e1[3];
    const DE = e1[3] * e2[4] - e2[3] * e1[4];
    const DF = e1[3] * e2[5] - e2[3] * e1[5];
    const BFpDE = BF + DE;
    const BEmCD = BE - CD;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](AB * BC - AC * AC, AB * BEmCD + AD * BC - 2 * AC * AE, AB * BFpDE + AD * BEmCD - AE * AE - 2 * AC * AF, AB * DF + AD * BFpDE - 2 * AE * AF, AD * DF - AF * AF);
}
/**
 * normalizeAngle
 *
 * @param {number} radians
 * @returns {number}
 */ function normalizeAngle(radians) {
    const normal = radians % TWO_PI;
    return normal < 0.0 ? normal + TWO_PI : normal;
}
/**
 * restrictPointsToArc
 *
 * @param {module:kld-intersections.Intersection} intersections
 * @param {module:kld-intersections.Point2D} center
 * @param {number} radiusX
 * @param {number} radiusY
 * @param {number} startRadians
 * @param {number} endRadians
 * @returns {module:kld-intersections.Intersection}
 */ function restrictPointsToArc(intersections, center, radiusX, radiusY, startRadians, endRadians) {
    if (intersections.points.length === 0) {
        return intersections;
    }
    const result = new Intersection("No Intersection");
    // swap if end is lower, so start is always the lower one
    if (endRadians < startRadians) {
        [startRadians, endRadians] = [
            endRadians,
            startRadians
        ];
    }
    // move everything to the positive domain, simultaneously
    if (startRadians < 0 || endRadians < 0) {
        startRadians += TWO_PI;
        endRadians += TWO_PI;
    }
    for (const p of intersections.points){
        let a = normalizeAngle(UNIT_X.angleBetween(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"].fromPoints(center, p)));
        // a angle smaller than start, it may still be between
        // this happens if end > TWO_PI
        if (a < startRadians) {
            a += TWO_PI;
        }
        if (startRadians <= a && a <= endRadians) {
            result.appendPoint(p);
        }
    }
    if (result.points.length > 0) {
        result.status = "Intersection";
    }
    return result;
}
/**
 *  closePolygon
 *  @memberof module:kld-intersections.Intersection
 *  @param {Array<module:kld-intersections.Point2D>} points
 *  @returns {Array<module:kld-intersections.Point2D>}
 */ function closePolygon(points) {
    const copy = points.slice();
    copy.push(points[0]);
    return copy;
}
/**
 * Intersection
 * @memberof module:kld-intersections
 */ class Intersection {
    /**
     *  @param {string} status
     *  @returns {module:kld-intersections.Intersection}
     */ constructor(status){
        this.init(status);
    }
    /**
     *  init
     *
     *  @param {string} status
     *  @returns {module:kld-intersections.Intersection}
     */ init(status) {
        this.status = status;
        this.points = [];
    }
    /**
     *  intersect
     *
     *  @param {module:kld-intersections.ShapeInfo} shape1
     *  @param {module:kld-intersections.ShapeInfo} shape2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersect(shape1, shape2) {
        let result;
        if (!isNullish(shape1) && !isNullish(shape2)) {
            if (shape1.name === "Path") {
                result = Intersection.intersectPathShape(shape1, shape2);
            } else if (shape2.name === "Path") {
                result = Intersection.intersectPathShape(shape2, shape1);
            } else if (shape1.name === "Arc") {
                result = Intersection.intersectArcShape(shape1, shape2);
            } else if (shape2.name === "Arc") {
                result = Intersection.intersectArcShape(shape2, shape1);
            } else {
                let method;
                let args;
                if (shape1.name < shape2.name) {
                    method = "intersect" + shape1.name + shape2.name;
                    args = shape1.args.concat(shape2.args);
                } else {
                    method = "intersect" + shape2.name + shape1.name;
                    args = shape2.args.concat(shape1.args);
                }
                if (!(method in Intersection)) {
                    throw new TypeError("Intersection not available: " + method);
                }
                result = Intersection[method].apply(null, args);
            }
        } else {
            result = new Intersection("No Intersection");
        }
        return result;
    }
    /**
     *  intersectPathShape
     *
     *  @param {module:kld-intersections.ShapeInfo} path
     *  @param {module:kld-intersections.ShapeInfo} shape
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectPathShape(path, shape) {
        const result = new Intersection("No Intersection");
        for (const segment of path.args){
            const inter = Intersection.intersect(segment, shape);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     * intersectArcShape
     *
     * @param {module:kld-intersections.ShapeInfo} arc
     * @param {module:kld-intersections.ShapeInfo} shape
     * @returns {module:kld-intersections.Intersection}
     */ static intersectArcShape(arc, shape) {
        const [center, radiusX, radiusY, startRadians, endRadians] = arc.args;
        const ellipse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ELLIPSE, [
            center,
            radiusX,
            radiusY
        ]);
        const ellipse_result = Intersection.intersect(ellipse, shape);
        // return ellipse_result;
        return restrictPointsToArc(ellipse_result, center, radiusX, radiusY, startRadians, endRadians);
    }
    /**
     *  intersectBezier2Bezier2
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} a3
     *  @param {module:kld-intersections.Point2D} b1
     *  @param {module:kld-intersections.Point2D} b2
     *  @param {module:kld-intersections.Point2D} b3
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Bezier2(a1, a2, a3, b1, b2, b3) {
        let a, b;
        const result = new Intersection("No Intersection");
        a = a2.multiply(-2);
        const c12 = a1.add(a.add(a3));
        a = a1.multiply(-2);
        b = a2.multiply(2);
        const c11 = a.add(b);
        const c10 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](a1.x, a1.y);
        a = b2.multiply(-2);
        const c22 = b1.add(a.add(b3));
        a = b1.multiply(-2);
        b = b2.multiply(2);
        const c21 = a.add(b);
        const c20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](b1.x, b1.y);
        // bezout
        a = c12.x * c11.y - c11.x * c12.y;
        b = c22.x * c11.y - c11.x * c22.y;
        const c = c21.x * c11.y - c11.x * c21.y;
        const d = c11.x * (c10.y - c20.y) + c11.y * (-c10.x + c20.x);
        const e = c22.x * c12.y - c12.x * c22.y;
        const f = c21.x * c12.y - c12.x * c21.y;
        const g = c12.x * (c10.y - c20.y) + c12.y * (-c10.x + c20.x);
        // determinant
        const poly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](-e * e, -2 * e * f, a * b - f * f - 2 * e * g, a * c - 2 * f * g, a * d - g * g);
        const roots = poly.getRoots();
        for (const s of roots){
            if (0 <= s && s <= 1) {
                const xp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x);
                xp.simplifyEquals();
                const xRoots = xp.getRoots();
                const yp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y);
                yp.simplifyEquals();
                const yRoots = yp.getRoots();
                if (xRoots.length > 0 && yRoots.length > 0) {
                    const TOLERANCE = 1e-4;
                    checkRoots: for (const xRoot of xRoots){
                        if (0 <= xRoot && xRoot <= 1) {
                            for(let k = 0; k < yRoots.length; k++){
                                if (Math.abs(xRoot - yRoots[k]) < TOLERANCE) {
                                    result.points.push(c22.multiply(s * s).add(c21.multiply(s).add(c20)));
                                    break checkRoots;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier2Bezier3
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} a3
     *  @param {module:kld-intersections.Point2D} b1
     *  @param {module:kld-intersections.Point2D} b2
     *  @param {module:kld-intersections.Point2D} b3
     *  @param {module:kld-intersections.Point2D} b4
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Bezier3(a1, a2, a3, b1, b2, b3, b4) {
        let a, b, c, d;
        const result = new Intersection("No Intersection");
        a = a2.multiply(-2);
        const c12 = a1.add(a.add(a3));
        a = a1.multiply(-2);
        b = a2.multiply(2);
        const c11 = a.add(b);
        const c10 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](a1.x, a1.y);
        a = b1.multiply(-1);
        b = b2.multiply(3);
        c = b3.multiply(-3);
        d = a.add(b.add(c.add(b4)));
        const c23 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = b1.multiply(3);
        b = b2.multiply(-6);
        c = b3.multiply(3);
        d = a.add(b.add(c));
        const c22 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = b1.multiply(-3);
        b = b2.multiply(3);
        c = a.add(b);
        const c21 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](c.x, c.y);
        const c20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](b1.x, b1.y);
        const c10x2 = c10.x * c10.x;
        const c10y2 = c10.y * c10.y;
        const c11x2 = c11.x * c11.x;
        const c11y2 = c11.y * c11.y;
        const c12x2 = c12.x * c12.x;
        const c12y2 = c12.y * c12.y;
        const c20x2 = c20.x * c20.x;
        const c20y2 = c20.y * c20.y;
        const c21x2 = c21.x * c21.x;
        const c21y2 = c21.y * c21.y;
        const c22x2 = c22.x * c22.x;
        const c22y2 = c22.y * c22.y;
        const c23x2 = c23.x * c23.x;
        const c23y2 = c23.y * c23.y;
        const poly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](-2 * c12.x * c12.y * c23.x * c23.y + c12x2 * c23y2 + c12y2 * c23x2, -2 * c12.x * c12.y * c22.x * c23.y - 2 * c12.x * c12.y * c22.y * c23.x + 2 * c12y2 * c22.x * c23.x + 2 * c12x2 * c22.y * c23.y, -2 * c12.x * c21.x * c12.y * c23.y - 2 * c12.x * c12.y * c21.y * c23.x - 2 * c12.x * c12.y * c22.x * c22.y + 2 * c21.x * c12y2 * c23.x + c12y2 * c22x2 + c12x2 * (2 * c21.y * c23.y + c22y2), 2 * c10.x * c12.x * c12.y * c23.y + 2 * c10.y * c12.x * c12.y * c23.x + c11.x * c11.y * c12.x * c23.y + c11.x * c11.y * c12.y * c23.x - 2 * c20.x * c12.x * c12.y * c23.y - 2 * c12.x * c20.y * c12.y * c23.x - 2 * c12.x * c21.x * c12.y * c22.y - 2 * c12.x * c12.y * c21.y * c22.x - 2 * c10.x * c12y2 * c23.x - 2 * c10.y * c12x2 * c23.y + 2 * c20.x * c12y2 * c23.x + 2 * c21.x * c12y2 * c22.x - c11y2 * c12.x * c23.x - c11x2 * c12.y * c23.y + c12x2 * (2 * c20.y * c23.y + 2 * c21.y * c22.y), 2 * c10.x * c12.x * c12.y * c22.y + 2 * c10.y * c12.x * c12.y * c22.x + c11.x * c11.y * c12.x * c22.y + c11.x * c11.y * c12.y * c22.x - 2 * c20.x * c12.x * c12.y * c22.y - 2 * c12.x * c20.y * c12.y * c22.x - 2 * c12.x * c21.x * c12.y * c21.y - 2 * c10.x * c12y2 * c22.x - 2 * c10.y * c12x2 * c22.y + 2 * c20.x * c12y2 * c22.x - c11y2 * c12.x * c22.x - c11x2 * c12.y * c22.y + c21x2 * c12y2 + c12x2 * (2 * c20.y * c22.y + c21y2), 2 * c10.x * c12.x * c12.y * c21.y + 2 * c10.y * c12.x * c21.x * c12.y + c11.x * c11.y * c12.x * c21.y + c11.x * c11.y * c21.x * c12.y - 2 * c20.x * c12.x * c12.y * c21.y - 2 * c12.x * c20.y * c21.x * c12.y - 2 * c10.x * c21.x * c12y2 - 2 * c10.y * c12x2 * c21.y + 2 * c20.x * c21.x * c12y2 - c11y2 * c12.x * c21.x - c11x2 * c12.y * c21.y + 2 * c12x2 * c20.y * c21.y, -2 * c10.x * c10.y * c12.x * c12.y - c10.x * c11.x * c11.y * c12.y - c10.y * c11.x * c11.y * c12.x + 2 * c10.x * c12.x * c20.y * c12.y + 2 * c10.y * c20.x * c12.x * c12.y + c11.x * c20.x * c11.y * c12.y + c11.x * c11.y * c12.x * c20.y - 2 * c20.x * c12.x * c20.y * c12.y - 2 * c10.x * c20.x * c12y2 + c10.x * c11y2 * c12.x + c10.y * c11x2 * c12.y - 2 * c10.y * c12x2 * c20.y - c20.x * c11y2 * c12.x - c11x2 * c20.y * c12.y + c10x2 * c12y2 + c10y2 * c12x2 + c20x2 * c12y2 + c12x2 * c20y2);
        const roots = poly.getRootsInInterval(0, 1);
        for (const s of roots){
            const xRoots = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x).getRoots();
            const yRoots = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y).getRoots();
            if (xRoots.length > 0 && yRoots.length > 0) {
                const TOLERANCE = 1e-4;
                checkRoots: for (const xRoot of xRoots){
                    if (0 <= xRoot && xRoot <= 1) {
                        for(let k = 0; k < yRoots.length; k++){
                            if (Math.abs(xRoot - yRoots[k]) < TOLERANCE) {
                                result.points.push(c23.multiply(s * s * s).add(c22.multiply(s * s).add(c21.multiply(s).add(c20))));
                                break checkRoots;
                            }
                        }
                    }
                }
            }
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier2Circle
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} r
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Circle(p1, p2, p3, c, r) {
        return Intersection.intersectBezier2Ellipse(p1, p2, p3, c, r, r);
    }
    /**
     *  intersectBezier2Ellipse
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} ec
     *  @param {number} rx
     *  @param {number} ry
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Ellipse(p1, p2, p3, ec, rx, ry) {
        let a; // temporary variables
        // c2, c1, c0; // coefficients of quadratic
        const result = new Intersection("No Intersection");
        a = p2.multiply(-2);
        const c2 = p1.add(a.add(p3));
        a = p1.multiply(-2);
        const b = p2.multiply(2);
        const c1 = a.add(b);
        const c0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](p1.x, p1.y);
        const rxrx = rx * rx;
        const ryry = ry * ry;
        const roots = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](ryry * c2.x * c2.x + rxrx * c2.y * c2.y, 2 * (ryry * c2.x * c1.x + rxrx * c2.y * c1.y), ryry * (2 * c2.x * c0.x + c1.x * c1.x) + rxrx * (2 * c2.y * c0.y + c1.y * c1.y) - 2 * (ryry * ec.x * c2.x + rxrx * ec.y * c2.y), 2 * (ryry * c1.x * (c0.x - ec.x) + rxrx * c1.y * (c0.y - ec.y)), ryry * (c0.x * c0.x + ec.x * ec.x) + rxrx * (c0.y * c0.y + ec.y * ec.y) - 2 * (ryry * ec.x * c0.x + rxrx * ec.y * c0.y) - rxrx * ryry).getRoots();
        for (const t of roots){
            if (0 <= t && t <= 1) {
                result.points.push(c2.multiply(t * t).add(c1.multiply(t).add(c0)));
            }
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier2Line
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Line(p1, p2, p3, a1, a2) {
        let a; // temporary variables
        // let c2, c1, c0; // coefficients of quadratic
        // cl; // c coefficient for normal form of line
        // n; // normal for normal form of line
        const min = a1.min(a2); // used to determine if point is on line segment
        const max = a1.max(a2); // used to determine if point is on line segment
        const result = new Intersection("No Intersection");
        a = p2.multiply(-2);
        const c2 = p1.add(a.add(p3));
        a = p1.multiply(-2);
        const b = p2.multiply(2);
        const c1 = a.add(b);
        const c0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](p1.x, p1.y);
        // Convert line to normal form: ax + by + c = 0
        // Find normal to line: negative inverse of original line's slope
        const n = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](a1.y - a2.y, a2.x - a1.x);
        // Determine new c coefficient
        const cl = a1.x * a2.y - a2.x * a1.y;
        // Transform cubic coefficients to line's coordinate system and find roots
        // of cubic
        const roots = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](n.dot(c2), n.dot(c1), n.dot(c0) + cl).getRoots();
        // Any roots in closed interval [0,1] are intersections on Bezier, but
        // might not be on the line segment.
        // Find intersections and calculate point coordinates
        for (const t of roots){
            if (0 <= t && t <= 1) {
                // We're within the Bezier curve
                // Find point on Bezier
                const p4 = p1.lerp(p2, t);
                const p5 = p2.lerp(p3, t);
                const p6 = p4.lerp(p5, t);
                // See if point is on line segment
                // Had to make special cases for vertical and horizontal lines due
                // to slight errors in calculation of p6
                if (a1.x === a2.x) {
                    if (min.y <= p6.y && p6.y <= max.y) {
                        result.status = "Intersection";
                        result.appendPoint(p6);
                    }
                } else if (a1.y === a2.y) {
                    if (min.x <= p6.x && p6.x <= max.x) {
                        result.status = "Intersection";
                        result.appendPoint(p6);
                    }
                } else if (min.x <= p6.x && p6.x <= max.x && min.y <= p6.y && p6.y <= max.y) {
                    result.status = "Intersection";
                    result.appendPoint(p6);
                }
            }
        }
        return result;
    }
    /**
     *  intersectBezier2Polygon
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Polygon(p1, p2, p3, points) {
        return Intersection.intersectBezier2Polyline(p1, p2, p3, closePolygon(points));
    }
    /**
     *  intersectBezier2Polyline
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Polyline(p1, p2, p3, points) {
        const result = new Intersection("No Intersection");
        const { length: len } = points;
        for(let i = 0; i < len - 1; i++){
            const a1 = points[i];
            const a2 = points[i + 1];
            const inter = Intersection.intersectBezier2Line(p1, p2, p3, a1, a2);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier2Rectangle
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier2Rectangle(p1, p2, p3, r1, r2) {
        const min = r1.min(r2);
        const max = r1.max(r2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectBezier2Line(p1, p2, p3, min, topRight);
        const inter2 = Intersection.intersectBezier2Line(p1, p2, p3, topRight, max);
        const inter3 = Intersection.intersectBezier2Line(p1, p2, p3, max, bottomLeft);
        const inter4 = Intersection.intersectBezier2Line(p1, p2, p3, bottomLeft, min);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier3Bezier3
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} a3
     *  @param {module:kld-intersections.Point2D} a4
     *  @param {module:kld-intersections.Point2D} b1
     *  @param {module:kld-intersections.Point2D} b2
     *  @param {module:kld-intersections.Point2D} b3
     *  @param {module:kld-intersections.Point2D} b4
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Bezier3(a1, a2, a3, a4, b1, b2, b3, b4) {
        let a, b, c, d; // temporary variables
        // c13, c12, c11, c10; // coefficients of cubic
        // c23, c22, c21, c20; // coefficients of cubic
        const result = new Intersection("No Intersection");
        // Calculate the coefficients of cubic polynomial
        a = a1.multiply(-1);
        b = a2.multiply(3);
        c = a3.multiply(-3);
        d = a.add(b.add(c.add(a4)));
        const c13 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = a1.multiply(3);
        b = a2.multiply(-6);
        c = a3.multiply(3);
        d = a.add(b.add(c));
        const c12 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = a1.multiply(-3);
        b = a2.multiply(3);
        c = a.add(b);
        const c11 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](c.x, c.y);
        const c10 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](a1.x, a1.y);
        a = b1.multiply(-1);
        b = b2.multiply(3);
        c = b3.multiply(-3);
        d = a.add(b.add(c.add(b4)));
        const c23 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = b1.multiply(3);
        b = b2.multiply(-6);
        c = b3.multiply(3);
        d = a.add(b.add(c));
        const c22 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = b1.multiply(-3);
        b = b2.multiply(3);
        c = a.add(b);
        const c21 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](c.x, c.y);
        const c20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](b1.x, b1.y);
        // bezout
        a = c13.x * c12.y - c12.x * c13.y;
        b = c13.x * c11.y - c11.x * c13.y;
        const c0 = c13.x * c10.y - c10.x * c13.y + c20.x * c13.y - c13.x * c20.y;
        const c1 = c21.x * c13.y - c13.x * c21.y;
        const c2 = c22.x * c13.y - c13.x * c22.y;
        const c3 = c23.x * c13.y - c13.x * c23.y;
        d = c13.x * c11.y - c11.x * c13.y;
        const e0 = c13.x * c10.y + c12.x * c11.y - c11.x * c12.y - c10.x * c13.y + c20.x * c13.y - c13.x * c20.y;
        const e1 = c21.x * c13.y - c13.x * c21.y;
        const e2 = c22.x * c13.y - c13.x * c22.y;
        const e3 = c23.x * c13.y - c13.x * c23.y;
        const f0 = c12.x * c10.y - c10.x * c12.y + c20.x * c12.y - c12.x * c20.y;
        const f1 = c21.x * c12.y - c12.x * c21.y;
        const f2 = c22.x * c12.y - c12.x * c22.y;
        const f3 = c23.x * c12.y - c12.x * c23.y;
        const g0 = c13.x * c10.y - c10.x * c13.y + c20.x * c13.y - c13.x * c20.y;
        const g1 = c21.x * c13.y - c13.x * c21.y;
        const g2 = c22.x * c13.y - c13.x * c22.y;
        const g3 = c23.x * c13.y - c13.x * c23.y;
        const h0 = c12.x * c10.y - c10.x * c12.y + c20.x * c12.y - c12.x * c20.y;
        const h1 = c21.x * c12.y - c12.x * c21.y;
        const h2 = c22.x * c12.y - c12.x * c22.y;
        const h3 = c23.x * c12.y - c12.x * c23.y;
        const i0 = c11.x * c10.y - c10.x * c11.y + c20.x * c11.y - c11.x * c20.y;
        const i1 = c21.x * c11.y - c11.x * c21.y;
        const i2 = c22.x * c11.y - c11.x * c22.y;
        const i3 = c23.x * c11.y - c11.x * c23.y;
        // determinant
        const poly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](-c3 * e3 * g3, -c3 * e3 * g2 - c3 * e2 * g3 - c2 * e3 * g3, -c3 * e3 * g1 - c3 * e2 * g2 - c2 * e3 * g2 - c3 * e1 * g3 - c2 * e2 * g3 - c1 * e3 * g3, -c3 * e3 * g0 - c3 * e2 * g1 - c2 * e3 * g1 - c3 * e1 * g2 - c2 * e2 * g2 - c1 * e3 * g2 - c3 * e0 * g3 - c2 * e1 * g3 - c1 * e2 * g3 - c0 * e3 * g3 + b * f3 * g3 + c3 * d * h3 - a * f3 * h3 + a * e3 * i3, -c3 * e2 * g0 - c2 * e3 * g0 - c3 * e1 * g1 - c2 * e2 * g1 - c1 * e3 * g1 - c3 * e0 * g2 - c2 * e1 * g2 - c1 * e2 * g2 - c0 * e3 * g2 + b * f3 * g2 - c2 * e0 * g3 - c1 * e1 * g3 - c0 * e2 * g3 + b * f2 * g3 + c3 * d * h2 - a * f3 * h2 + c2 * d * h3 - a * f2 * h3 + a * e3 * i2 + a * e2 * i3, -c3 * e1 * g0 - c2 * e2 * g0 - c1 * e3 * g0 - c3 * e0 * g1 - c2 * e1 * g1 - c1 * e2 * g1 - c0 * e3 * g1 + b * f3 * g1 - c2 * e0 * g2 - c1 * e1 * g2 - c0 * e2 * g2 + b * f2 * g2 - c1 * e0 * g3 - c0 * e1 * g3 + b * f1 * g3 + c3 * d * h1 - a * f3 * h1 + c2 * d * h2 - a * f2 * h2 + c1 * d * h3 - a * f1 * h3 + a * e3 * i1 + a * e2 * i2 + a * e1 * i3, -c3 * e0 * g0 - c2 * e1 * g0 - c1 * e2 * g0 - c0 * e3 * g0 + b * f3 * g0 - c2 * e0 * g1 - c1 * e1 * g1 - c0 * e2 * g1 + b * f2 * g1 - c1 * e0 * g2 - c0 * e1 * g2 + b * f1 * g2 - c0 * e0 * g3 + b * f0 * g3 + c3 * d * h0 - a * f3 * h0 + c2 * d * h1 - a * f2 * h1 + c1 * d * h2 - a * f1 * h2 + c0 * d * h3 - a * f0 * h3 + a * e3 * i0 + a * e2 * i1 + a * e1 * i2 - b * d * i3 + a * e0 * i3, -c2 * e0 * g0 - c1 * e1 * g0 - c0 * e2 * g0 + b * f2 * g0 - c1 * e0 * g1 - c0 * e1 * g1 + b * f1 * g1 - c0 * e0 * g2 + b * f0 * g2 + c2 * d * h0 - a * f2 * h0 + c1 * d * h1 - a * f1 * h1 + c0 * d * h2 - a * f0 * h2 + a * e2 * i0 + a * e1 * i1 - b * d * i2 + a * e0 * i2, -c1 * e0 * g0 - c0 * e1 * g0 + b * f1 * g0 - c0 * e0 * g1 + b * f0 * g1 + c1 * d * h0 - a * f1 * h0 + c0 * d * h1 - a * f0 * h1 + a * e1 * i0 - b * d * i1 + a * e0 * i1, -c0 * e0 * g0 + b * f0 * g0 + c0 * d * h0 - a * f0 * h0 - b * d * i0 + a * e0 * i0);
        poly.simplifyEquals();
        const roots = poly.getRootsInInterval(0, 1);
        for (const s of roots){
            const xp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c13.x, c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x);
            xp.simplifyEquals();
            const xRoots = xp.getRoots();
            const yp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c13.y, c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y);
            yp.simplifyEquals();
            const yRoots = yp.getRoots();
            if (xRoots.length > 0 && yRoots.length > 0) {
                const TOLERANCE = 1e-4;
                checkRoots: for (const xRoot of xRoots){
                    if (0 <= xRoot && xRoot <= 1) {
                        for(let k = 0; k < yRoots.length; k++){
                            if (Math.abs(xRoot - yRoots[k]) < TOLERANCE) {
                                result.points.push(c23.multiply(s * s * s).add(c22.multiply(s * s).add(c21.multiply(s).add(c20))));
                                break checkRoots;
                            }
                        }
                    }
                }
            }
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier3Circle
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} r
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Circle(p1, p2, p3, p4, c, r) {
        return Intersection.intersectBezier3Ellipse(p1, p2, p3, p4, c, r, r);
    }
    /**
     *  intersectBezier3Ellipse
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @param {module:kld-intersections.Point2D} ec
     *  @param {number} rx
     *  @param {number} ry
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Ellipse(p1, p2, p3, p4, ec, rx, ry) {
        let a, b, c, d; // temporary variables
        // c3, c2, c1, c0; // coefficients of cubic
        const result = new Intersection("No Intersection");
        // Calculate the coefficients of cubic polynomial
        a = p1.multiply(-1);
        b = p2.multiply(3);
        c = p3.multiply(-3);
        d = a.add(b.add(c.add(p4)));
        const c3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = p1.multiply(3);
        b = p2.multiply(-6);
        c = p3.multiply(3);
        d = a.add(b.add(c));
        const c2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](d.x, d.y);
        a = p1.multiply(-3);
        b = p2.multiply(3);
        c = a.add(b);
        const c1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](c.x, c.y);
        const c0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](p1.x, p1.y);
        const rxrx = rx * rx;
        const ryry = ry * ry;
        const poly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](c3.x * c3.x * ryry + c3.y * c3.y * rxrx, 2 * (c3.x * c2.x * ryry + c3.y * c2.y * rxrx), 2 * (c3.x * c1.x * ryry + c3.y * c1.y * rxrx) + c2.x * c2.x * ryry + c2.y * c2.y * rxrx, 2 * c3.x * ryry * (c0.x - ec.x) + 2 * c3.y * rxrx * (c0.y - ec.y) + 2 * (c2.x * c1.x * ryry + c2.y * c1.y * rxrx), 2 * c2.x * ryry * (c0.x - ec.x) + 2 * c2.y * rxrx * (c0.y - ec.y) + c1.x * c1.x * ryry + c1.y * c1.y * rxrx, 2 * c1.x * ryry * (c0.x - ec.x) + 2 * c1.y * rxrx * (c0.y - ec.y), c0.x * c0.x * ryry - 2 * c0.y * ec.y * rxrx - 2 * c0.x * ec.x * ryry + c0.y * c0.y * rxrx + ec.x * ec.x * ryry + ec.y * ec.y * rxrx - rxrx * ryry);
        const roots = poly.getRootsInInterval(0, 1);
        for (const t of roots){
            result.points.push(c3.multiply(t * t * t).add(c2.multiply(t * t).add(c1.multiply(t).add(c0))));
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier3Line
     *
     *  Many thanks to Dan Sunday at SoftSurfer.com.  He gave me a very thorough
     *  sketch of the algorithm used here.  Without his help, I'm not sure when I
     *  would have figured out this intersection problem.
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Line(p1, p2, p3, p4, a1, a2) {
        let a, b, c, d; // temporary variables
        // c3, c2, c1, c0; // coefficients of cubic
        // cl; // c coefficient for normal form of line
        // n; // normal for normal form of line
        const min = a1.min(a2); // used to determine if point is on line segment
        const max = a1.max(a2); // used to determine if point is on line segment
        const result = new Intersection("No Intersection");
        // Start with Bezier using Bernstein polynomials for weighting functions:
        //     (1-t^3)P1 + 3t(1-t)^2P2 + 3t^2(1-t)P3 + t^3P4
        //
        // Expand and collect terms to form linear combinations of original Bezier
        // controls.  This ends up with a vector cubic in t:
        //     (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1
        //             /\                  /\                /\       /\
        //             ||                  ||                ||       ||
        //             c3                  c2                c1       c0
        // Calculate the coefficients
        a = p1.multiply(-1);
        b = p2.multiply(3);
        c = p3.multiply(-3);
        d = a.add(b.add(c.add(p4)));
        const c3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](d.x, d.y);
        a = p1.multiply(3);
        b = p2.multiply(-6);
        c = p3.multiply(3);
        d = a.add(b.add(c));
        const c2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](d.x, d.y);
        a = p1.multiply(-3);
        b = p2.multiply(3);
        c = a.add(b);
        const c1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](c.x, c.y);
        const c0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](p1.x, p1.y);
        // Convert line to normal form: ax + by + c = 0
        // Find normal to line: negative inverse of original line's slope
        const n = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](a1.y - a2.y, a2.x - a1.x);
        // Determine new c coefficient
        const cl = a1.x * a2.y - a2.x * a1.y;
        // ?Rotate each cubic coefficient using line for new coordinate system?
        // Find roots of rotated cubic
        const roots = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](n.dot(c3), n.dot(c2), n.dot(c1), n.dot(c0) + cl).getRoots();
        // Any roots in closed interval [0,1] are intersections on Bezier, but
        // might not be on the line segment.
        // Find intersections and calculate point coordinates
        for (const t of roots){
            if (0 <= t && t <= 1) {
                // We're within the Bezier curve
                // Find point on Bezier
                const p5 = p1.lerp(p2, t);
                const p6 = p2.lerp(p3, t);
                const p7 = p3.lerp(p4, t);
                const p8 = p5.lerp(p6, t);
                const p9 = p6.lerp(p7, t);
                const p10 = p8.lerp(p9, t);
                // See if point is on line segment
                // Had to make special cases for vertical and horizontal lines due
                // to slight errors in calculation of p10
                if (a1.x === a2.x) {
                    if (min.y <= p10.y && p10.y <= max.y) {
                        result.status = "Intersection";
                        result.appendPoint(p10);
                    }
                } else if (a1.y === a2.y) {
                    if (min.x <= p10.x && p10.x <= max.x) {
                        result.status = "Intersection";
                        result.appendPoint(p10);
                    }
                } else if (min.x <= p10.x && p10.x <= max.x && min.y <= p10.y && p10.y <= max.y) {
                    result.status = "Intersection";
                    result.appendPoint(p10);
                }
            }
        }
        return result;
    }
    /**
     *  intersectBezier3Polygon
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Polygon(p1, p2, p3, p4, points) {
        return Intersection.intersectBezier3Polyline(p1, p2, p3, p4, closePolygon(points));
    }
    /**
     *  intersectBezier3Polyline
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Polyline(p1, p2, p3, p4, points) {
        const result = new Intersection("No Intersection");
        const { length: len } = points;
        for(let i = 0; i < len - 1; i++){
            const a1 = points[i];
            const a2 = points[i + 1];
            const inter = Intersection.intersectBezier3Line(p1, p2, p3, p4, a1, a2);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectBezier3Rectangle
     *
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectBezier3Rectangle(p1, p2, p3, p4, r1, r2) {
        const min = r1.min(r2);
        const max = r1.max(r2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectBezier3Line(p1, p2, p3, p4, min, topRight);
        const inter2 = Intersection.intersectBezier3Line(p1, p2, p3, p4, topRight, max);
        const inter3 = Intersection.intersectBezier3Line(p1, p2, p3, p4, max, bottomLeft);
        const inter4 = Intersection.intersectBezier3Line(p1, p2, p3, p4, bottomLeft, min);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectCircleCircle
     *
     *  @param {module:kld-intersections.Point2D} c1
     *  @param {number} r1
     *  @param {module:kld-intersections.Point2D} c2
     *  @param {number} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectCircleCircle(c1, r1, c2, r2) {
        let result;
        // Determine minimum and maximum radii where circles can intersect
        const r_max = r1 + r2;
        const r_min = Math.abs(r1 - r2);
        // Determine actual distance between circle circles
        const c_dist = c1.distanceFrom(c2);
        if (c_dist > r_max) {
            result = new Intersection("Outside");
        } else if (c_dist < r_min) {
            result = new Intersection("Inside");
        } else {
            result = new Intersection("Intersection");
            const a = (r1 * r1 - r2 * r2 + c_dist * c_dist) / (2 * c_dist);
            const h = Math.sqrt(r1 * r1 - a * a);
            const p = c1.lerp(c2, a / c_dist);
            const b = h / c_dist;
            result.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](p.x - b * (c2.y - c1.y), p.y + b * (c2.x - c1.x)));
            result.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](p.x + b * (c2.y - c1.y), p.y - b * (c2.x - c1.x)));
        }
        return result;
    }
    /**
     *  intersectCircleEllipse
     *
     *  @param {module:kld-intersections.Point2D} cc
     *  @param {number} r
     *  @param {module:kld-intersections.Point2D} ec
     *  @param {number} rx
     *  @param {number} ry
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectCircleEllipse(cc, r, ec, rx, ry) {
        return Intersection.intersectEllipseEllipse(cc, r, r, ec, rx, ry);
    }
    /**
     *  intersectCircleLine
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} r
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectCircleLine(c, r, a1, a2) {
        let result;
        const a = (a2.x - a1.x) * (a2.x - a1.x) + (a2.y - a1.y) * (a2.y - a1.y);
        const b = 2 * ((a2.x - a1.x) * (a1.x - c.x) + (a2.y - a1.y) * (a1.y - c.y));
        const cc = c.x * c.x + c.y * c.y + a1.x * a1.x + a1.y * a1.y - 2 * (c.x * a1.x + c.y * a1.y) - r * r;
        const deter = b * b - 4 * a * cc;
        if (deter < 0) {
            result = new Intersection("Outside");
        } else if (deter === 0) {
            result = new Intersection("Tangent");
        // NOTE: should calculate this point
        } else {
            const e = Math.sqrt(deter);
            const u1 = (-b + e) / (2 * a);
            const u2 = (-b - e) / (2 * a);
            if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
                if (u1 < 0 && u2 < 0 || u1 > 1 && u2 > 1) {
                    result = new Intersection("Outside");
                } else {
                    result = new Intersection("Inside");
                }
            } else {
                result = new Intersection("Intersection");
                if (0 <= u1 && u1 <= 1) {
                    result.points.push(a1.lerp(a2, u1));
                }
                if (0 <= u2 && u2 <= 1) {
                    result.points.push(a1.lerp(a2, u2));
                }
            }
        }
        return result;
    }
    /**
     *  intersectCirclePolygon
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} r
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectCirclePolygon(c, r, points) {
        return Intersection.intersectCirclePolyline(c, r, closePolygon(points));
    }
    /**
     *  intersectCirclePolyline
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} r
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectCirclePolyline(c, r, points) {
        const result = new Intersection("No Intersection");
        const { length: len } = points;
        let inter;
        for(let i = 0; i < len - 1; i++){
            const a1 = points[i];
            const a2 = points[i + 1];
            inter = Intersection.intersectCircleLine(c, r, a1, a2);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        } else {
            result.status = inter.status;
        }
        return result;
    }
    /**
     *  intersectCircleRectangle
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} r
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectCircleRectangle(c, r, r1, r2) {
        const min = r1.min(r2);
        const max = r1.max(r2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectCircleLine(c, r, min, topRight);
        const inter2 = Intersection.intersectCircleLine(c, r, topRight, max);
        const inter3 = Intersection.intersectCircleLine(c, r, max, bottomLeft);
        const inter4 = Intersection.intersectCircleLine(c, r, bottomLeft, min);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        } else {
            result.status = inter1.status;
        }
        return result;
    }
    /**
     *  intersectEllipseEllipse
     *
     *  This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His
     *  code along with many other excellent examples are avaiable at his site:
     *  http://www.magic-software.com
     *
     *  NOTE: Rotation will need to be added to this function
     *
     *  @param {module:kld-intersections.Point2D} c1
     *  @param {number} rx1
     *  @param {number} ry1
     *  @param {module:kld-intersections.Point2D} c2
     *  @param {number} rx2
     *  @param {number} ry2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectEllipseEllipse(c1, rx1, ry1, c2, rx2, ry2) {
        const a = [
            ry1 * ry1,
            0,
            rx1 * rx1,
            -2 * ry1 * ry1 * c1.x,
            -2 * rx1 * rx1 * c1.y,
            ry1 * ry1 * c1.x * c1.x + rx1 * rx1 * c1.y * c1.y - rx1 * rx1 * ry1 * ry1
        ];
        const b = [
            ry2 * ry2,
            0,
            rx2 * rx2,
            -2 * ry2 * ry2 * c2.x,
            -2 * rx2 * rx2 * c2.y,
            ry2 * ry2 * c2.x * c2.x + rx2 * rx2 * c2.y * c2.y - rx2 * rx2 * ry2 * ry2
        ];
        const yPoly = bezout(a, b);
        const yRoots = yPoly.getRoots();
        const epsilon = 1e-3;
        const norm0 = (a[0] * a[0] + 2 * a[1] * a[1] + a[2] * a[2]) * epsilon;
        const norm1 = (b[0] * b[0] + 2 * b[1] * b[1] + b[2] * b[2]) * epsilon;
        const result = new Intersection("No Intersection");
        for(let y = 0; y < yRoots.length; y++){
            const xPoly = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$polynomial$2f$lib$2f$Polynomial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Polynomial$3e$__["Polynomial"](a[0], a[3] + yRoots[y] * a[1], a[5] + yRoots[y] * (a[4] + yRoots[y] * a[2]));
            const xRoots = xPoly.getRoots();
            for(let x = 0; x < xRoots.length; x++){
                let tst = (a[0] * xRoots[x] + a[1] * yRoots[y] + a[3]) * xRoots[x] + (a[2] * yRoots[y] + a[4]) * yRoots[y] + a[5];
                if (Math.abs(tst) < norm0) {
                    tst = (b[0] * xRoots[x] + b[1] * yRoots[y] + b[3]) * xRoots[x] + (b[2] * yRoots[y] + b[4]) * yRoots[y] + b[5];
                    if (Math.abs(tst) < norm1) {
                        result.appendPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](xRoots[x], yRoots[y]));
                    }
                }
            }
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectEllipseLine
     *
     *  NOTE: Rotation will need to be added to this function
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} rx
     *  @param {number} ry
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectEllipseLine(c, rx, ry, a1, a2) {
        let result;
        const orign = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](a1.x, a1.y);
        const dir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"].fromPoints(a1, a2);
        const center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](c.x, c.y);
        const diff = orign.subtract(center);
        const mDir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](dir.x / (rx * rx), dir.y / (ry * ry));
        const mDiff = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"](diff.x / (rx * rx), diff.y / (ry * ry));
        const a = dir.dot(mDir);
        const b = dir.dot(mDiff);
        c = diff.dot(mDiff) - 1.0;
        const d = b * b - a * c;
        if (d < 0) {
            result = new Intersection("Outside");
        } else if (d > 0) {
            const root = Math.sqrt(d); // eslint-disable-line no-shadow
            const t_a = (-b - root) / a;
            const t_b = (-b + root) / a;
            if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
                if (t_a < 0 && t_b < 0 || t_a > 1 && t_b > 1) {
                    result = new Intersection("Outside");
                } else {
                    result = new Intersection("Inside");
                }
            } else {
                result = new Intersection("Intersection");
                if (0 <= t_a && t_a <= 1) {
                    result.appendPoint(a1.lerp(a2, t_a));
                }
                if (0 <= t_b && t_b <= 1) {
                    result.appendPoint(a1.lerp(a2, t_b));
                }
            }
        } else {
            const t = -b / a;
            if (0 <= t && t <= 1) {
                result = new Intersection("Intersection");
                result.appendPoint(a1.lerp(a2, t));
            } else {
                result = new Intersection("Outside");
            }
        }
        return result;
    }
    /**
     *  intersectEllipsePolygon
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} rx
     *  @param {number} ry
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectEllipsePolygon(c, rx, ry, points) {
        return Intersection.intersectEllipsePolyline(c, rx, ry, closePolygon(points));
    }
    /**
     *  intersectEllipsePolyline
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} rx
     *  @param {number} ry
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectEllipsePolyline(c, rx, ry, points) {
        const result = new Intersection("No Intersection");
        const { length: len } = points;
        for(let i = 0; i < len - 1; i++){
            const b1 = points[i];
            const b2 = points[i + 1];
            const inter = Intersection.intersectEllipseLine(c, rx, ry, b1, b2);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectEllipseRectangle
     *
     *  @param {module:kld-intersections.Point2D} c
     *  @param {number} rx
     *  @param {number} ry
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectEllipseRectangle(c, rx, ry, r1, r2) {
        const min = r1.min(r2);
        const max = r1.max(r2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectEllipseLine(c, rx, ry, min, topRight);
        const inter2 = Intersection.intersectEllipseLine(c, rx, ry, topRight, max);
        const inter3 = Intersection.intersectEllipseLine(c, rx, ry, max, bottomLeft);
        const inter4 = Intersection.intersectEllipseLine(c, rx, ry, bottomLeft, min);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectLineLine
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} b1
     *  @param {module:kld-intersections.Point2D} b2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectLineLine(a1, a2, b1, b2) {
        let result;
        const ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
        const ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
        const u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
        if (u_b !== 0) {
            const ua = ua_t / u_b;
            const ub = ub_t / u_b;
            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
                result = new Intersection("Intersection");
                result.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
            } else {
                result = new Intersection("No Intersection");
            }
        } else if (ua_t === 0 || ub_t === 0) {
            result = new Intersection("Coincident");
        } else {
            result = new Intersection("Parallel");
        }
        return result;
    }
    /**
     *  intersectLinePolygon
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectLinePolygon(a1, a2, points) {
        return Intersection.intersectLinePolyline(a1, a2, closePolygon(points));
    }
    /**
     *  intersectLinePolyline
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectLinePolyline(a1, a2, points) {
        const result = new Intersection("No Intersection");
        const { length: len } = points;
        for(let i = 0; i < len - 1; i++){
            const b1 = points[i];
            const b2 = points[i + 1];
            const inter = Intersection.intersectLineLine(a1, a2, b1, b2);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectLineRectangle
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectLineRectangle(a1, a2, r1, r2) {
        const min = r1.min(r2);
        const max = r1.max(r2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectLineLine(min, topRight, a1, a2);
        const inter2 = Intersection.intersectLineLine(topRight, max, a1, a2);
        const inter3 = Intersection.intersectLineLine(max, bottomLeft, a1, a2);
        const inter4 = Intersection.intersectLineLine(bottomLeft, min, a1, a2);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectPolygonPolygon
     *
     *  @param {Array<module:kld-intersections.Point2D>} points1
     *  @param {Array<module:kld-intersections.Point2D>} points2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectPolygonPolygon(points1, points2) {
        return Intersection.intersectPolylinePolyline(closePolygon(points1), closePolygon(points2));
    }
    /**
     *  intersectPolygonPolyline
     *
     *  @param {Array<module:kld-intersections.Point2D>} points1
     *  @param {Array<module:kld-intersections.Point2D>} points2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectPolygonPolyline(points1, points2) {
        return Intersection.intersectPolylinePolyline(closePolygon(points1), points2);
    }
    /**
     *  intersectPolygonRectangle
     *
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectPolygonRectangle(points, r1, r2) {
        return Intersection.intersectPolylineRectangle(closePolygon(points), r1, r2);
    }
    /**
     *  intersectPolylinePolyline
     *
     *  @param {Array<module:kld-intersections.Point2D>} points1
     *  @param {Array<module:kld-intersections.Point2D>} points2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectPolylinePolyline(points1, points2) {
        const result = new Intersection("No Intersection");
        const { length: len } = points1;
        for(let i = 0; i < len - 1; i++){
            const a1 = points1[i];
            const a2 = points1[i + 1];
            const inter = Intersection.intersectLinePolyline(a1, a2, points2);
            result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectPolylineRectangle
     *
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @param {module:kld-intersections.Point2D} r1
     *  @param {module:kld-intersections.Point2D} r2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectPolylineRectangle(points, r1, r2) {
        const min = r1.min(r2);
        const max = r1.max(r2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectLinePolyline(min, topRight, points);
        const inter2 = Intersection.intersectLinePolyline(topRight, max, points);
        const inter3 = Intersection.intersectLinePolyline(max, bottomLeft, points);
        const inter4 = Intersection.intersectLinePolyline(bottomLeft, min, points);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectRectangleRectangle
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} b1
     *  @param {module:kld-intersections.Point2D} b2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectRectangleRectangle(a1, a2, b1, b2) {
        const min = a1.min(a2);
        const max = a1.max(a2);
        const topRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](max.x, min.y);
        const bottomLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](min.x, max.y);
        const inter1 = Intersection.intersectLineRectangle(min, topRight, b1, b2);
        const inter2 = Intersection.intersectLineRectangle(topRight, max, b1, b2);
        const inter3 = Intersection.intersectLineRectangle(max, bottomLeft, b1, b2);
        const inter4 = Intersection.intersectLineRectangle(bottomLeft, min, b1, b2);
        const result = new Intersection("No Intersection");
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
            result.status = "Intersection";
        }
        return result;
    }
    /**
     *  intersectRayRay
     *
     *  @param {module:kld-intersections.Point2D} a1
     *  @param {module:kld-intersections.Point2D} a2
     *  @param {module:kld-intersections.Point2D} b1
     *  @param {module:kld-intersections.Point2D} b2
     *  @returns {module:kld-intersections.Intersection}
     */ static intersectRayRay(a1, a2, b1, b2) {
        let result;
        const ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
        const ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
        const u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
        if (u_b !== 0) {
            const ua = ua_t / u_b;
            result = new Intersection("Intersection");
            result.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
        } else if (ua_t === 0 || ub_t === 0) {
            result = new Intersection("Coincident");
        } else {
            result = new Intersection("Parallel");
        }
        return result;
    }
    /**
     *  appendPoint
     *
     *  @param {module:kld-intersections.Point2D} point
     */ appendPoint(point) {
        this.points.push(point);
    }
    /**
     *  appendPoints
     *
     *  @param {Array<module:kld-intersections.Point2D>} points
     */ appendPoints(points) {
        this.points = this.points.concat(points);
    }
}
const __TURBOPACK__default__export__ = Intersection;
}}),
"[project]/node_modules/kld-intersections/lib/Shapes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable prefer-rest-params */ /**
 *  Shapes
 *
 *   @copyright 2017, Kevin Lindsey
 *   @module Shapes
 *   @deprecated use ShapeInfo
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)");
;
/**
 * Build shapes for intersection
 */ class Shapes {
    /**
     *  arc
     *
     *  @deprecated use ShapeInfo.arc
     *  @param {number} centerX
     *  @param {number} centerY
     *  @param {number} radiusX
     *  @param {number} radiusY
     *  @param {number} startRadians
     *  @param {number} endRadians
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static arc(centerX, centerY, radiusX, radiusY, startRadians, endRadians) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].arc(...arguments);
    }
    /**
     *  quadraticBezier
     *
     *  @deprecated use ShapeInfo.quadraticBezier
     *  @param {number} p1x
     *  @param {number} p1y
     *  @param {number} p2x
     *  @param {number} p2y
     *  @param {number} p3x
     *  @param {number} p3y
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static quadraticBezier(p1x, p1y, p2x, p2y, p3x, p3y) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].quadraticBezier(...arguments);
    }
    /**
     *  cubicBezier
     *
     *  @deprecated use ShapeInfo.cubicBezier
     *  @param {number} p1x
     *  @param {number} p1y
     *  @param {number} p2x
     *  @param {number} p2y
     *  @param {number} p3x
     *  @param {number} p3y
     *  @param {number} p4x
     *  @param {number} p4y
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static cubicBezier(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cubicBezier(...arguments);
    }
    /**
     *  circle
     *
     *  @deprecated use ShapeInfo.circle
     *  @param {number} centerX
     *  @param {number} centerY
     *  @param {number} radius
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static circle(centerX, centerY, radius) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].circle(...arguments);
    }
    /**
     *  ellipse
     *
     *  @deprecated use ShapeInfo.ellipse
     *  @param {number} centerX
     *  @param {number} centerY
     *  @param {number} radiusX
     *  @param {number} radiusY
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static ellipse(centerX, centerY, radiusX, radiusY) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ellipse(...arguments);
    }
    /**
     *  line
     *
     *  @deprecated use ShapeInfo.line
     *  @param {number} p1x
     *  @param {number} p1y
     *  @param {number} p2x
     *  @param {number} p2y
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static line(p1x, p1y, p2x, p2y) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].line(...arguments);
    }
    /**
     *  path
     *
     *  @deprecated use ShapeInfo.path
     *  @param {string} pathData
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static path(pathData) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].path(...arguments);
    }
    /**
     *  polygon
     *
     *  @deprecated use ShapeInfo.polygon
     *  @param {Array<number>} coords
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static polygon(coords) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].polygon(...arguments);
    }
    /**
     *  polyline
     *
     *  @deprecated use ShapeInfo.polyline
     *  @param {Array<number>} coords
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static polyline(coords) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].polyline(...arguments);
    }
    /**
     *  rectangle
     *
     *  @deprecated use ShapeInfo.rectangle
     *  @param {number} x
     *  @param {number} y
     *  @param {number} width
     *  @param {number} height
     *  @param {number} [rx]
     *  @param {number} [ry]
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static rectangle(x, y, width, height, rx = 0, ry = 0) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].rectangle(...arguments);
    }
}
const __TURBOPACK__default__export__ = Shapes;
}}),
"[project]/node_modules/kld-intersections/lib/AffineShapes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable prefer-rest-params */ /**
 *   AffineShapes
 *
 *   @copyright 2017-2019, Kevin Lindsey
 *   @module AffineShapes
 *   @deprecated use ShapeInfo
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)");
;
/**
 * Build shapes for intersection
 */ class AffineShapes {
    /**
     *  arc
     *
     *  @deprecated use ShapeInfo.arc
     *  @param {module:kld-intersections.Point2D} center
     *  @param {number} radiusX
     *  @param {number} radiusY
     *  @param {number} startRadians
     *  @param {number} endRadians
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static arc(center, radiusX, radiusY, startRadians, endRadians) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].arc(...arguments);
    }
    /**
     *  quadraticBezier
     *
     *   @deprecated use ShapeInfo.quadraticBezier
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static quadraticBezier(p1, p2, p3) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].quadraticBezier(...arguments);
    }
    /**
     *  cubicBezier
     *
     *  @deprecated use ShapeInfo.cubicBezier
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @param {module:kld-intersections.Point2D} p3
     *  @param {module:kld-intersections.Point2D} p4
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static cubicBezier(p1, p2, p3, p4) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cubicBezier(...arguments);
    }
    /**
     *  circle
     *
     *  @deprecated use ShapeInfo.circle
     *  @param {module:kld-intersections.Point2D} center
     *  @param {number} radius
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static circle(center, radius) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].circle(...arguments);
    }
    /**
     *  ellipse
     *
     *  @deprecated use ShapeInfo.ellipse
     *  @param {module:kld-intersections.Point2D} center
     *  @param {number} radiusX
     *  @param {number} radiusY
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static ellipse(center, radiusX, radiusY) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ellipse(...arguments);
    }
    /**
     *  line
     *
     *  @deprecated use ShapeInfo.line
     *  @param {module:kld-intersections.Point2D} p1
     *  @param {module:kld-intersections.Point2D} p2
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static line(p1, p2) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].line(...arguments);
    }
    /**
     *  path
     *
     *  @deprecated use ShapeInfo.path
     *  @param {string} pathData
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static path(pathData) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].path(...arguments);
    }
    /**
     *  polygon
     *
     *  @deprecated use ShapeInfo.polygon
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static polygon(points) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].polygon(...arguments);
    }
    /**
     *  polyline
     *
     *  @deprecated use ShapeInfo.polyline
     *  @param {Array<module:kld-intersections.Point2D>} points
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static polyline(points) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].polyline(...arguments);
    }
    /**
     *  rectangle
     *
     *  @deprecated use ShapeInfo.rectangle
     *  @param {module:kld-intersections.Point2D} topLeft
     *  @param {module:kld-intersections.Vector2D} size
     *  @param {number} [rx]
     *  @param {number} [ry]
     *  @returns {module:kld-intersections.ShapeInfo}
     */ static rectangle(topLeft, size, rx = 0, ry = 0) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].rectangle(...arguments);
    }
}
const __TURBOPACK__default__export__ = AffineShapes;
}}),
"[project]/node_modules/kld-intersections/lib/SvgShapes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable no-restricted-syntax */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Point2D.js [app-client] (ecmascript) <export default as Point2D>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)");
;
;
class SvgShapes {
    /**
     * circle
     *
     * @param {SVGCircleElement} circle
     * @returns {module:kld-intersections.ShapeInfo}
     */ static circle(circle) {
        if (circle instanceof SVGCircleElement === false) {
            throw new TypeError(`Expected SVGCircleElement, but found ${circle}`);
        }
        const center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](circle.cx.baseVal.value, circle.cy.baseVal.value);
        const radius = circle.r.baseVal.value;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].circle(center, radius);
    }
    /**
     * ellipse
     *
     * @param {SVGEllipseElement} ellipse
     * @returns {module:kld-intersections.ShapeInfo}
     */ static ellipse(ellipse) {
        if (ellipse instanceof SVGEllipseElement === false) {
            throw new TypeError(`Expected SVGEllipseElement, but found ${ellipse}`);
        }
        const center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](ellipse.cx.baseVal.value, ellipse.cy.baseVal.value);
        const radiusX = ellipse.rx.baseVal.value;
        const radiusY = ellipse.ry.baseVal.value;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ellipse(center, radiusX, radiusY);
    }
    /**
     * line
     *
     * @param {SVGLineElement} line
     * @returns {module:kld-intersections.ShapeInfo}
     */ static line(line) {
        if (line instanceof SVGLineElement === false) {
            throw new TypeError(`Expected SVGLineElement, but found ${line}`);
        }
        const p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](line.x1.baseVal.value, line.y1.baseVal.value);
        const p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](line.x2.baseVal.value, line.y2.baseVal.value);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].line(p1, p2);
    }
    /**
     * path
     *
     * @param {SVGPathElement} path
     * @returns {module:kld-intersections.ShapeInfo}
     */ static path(path) {
        if (path instanceof SVGPathElement === false) {
            throw new TypeError(`Expected SVGPathElement, but found ${path}`);
        }
        const pathData = path.getAttributeNS(null, "d");
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].path(pathData);
    }
    /**
     * polygon
     *
     * @param {SVGPolygonElement} polygon
     * @returns {module:kld-intersections.ShapeInfo}
     */ static polygon(polygon) {
        if (polygon instanceof SVGPolygonElement === false) {
            throw new TypeError(`Expected SVGPolygonElement, but found ${polygon}`);
        }
        const points = [];
        for(let i = 0; i < polygon.points.numberOfItems; i++){
            const point = polygon.points.getItem(i);
            points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](point.x, point.y));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].polygon(points);
    }
    /**
     * polyline
     *
     * @param {SVGPolylineElement} polyline
     * @returns {module:kld-intersections.ShapeInfo}
     */ static polyline(polyline) {
        if (polyline instanceof SVGPolylineElement === false) {
            throw new TypeError(`Expected SVGPolylineElement, but found ${polyline}`);
        }
        const points = [];
        for(let i = 0; i < polyline.points.numberOfItems; i++){
            const point = polyline.points.getItem(i);
            points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Point2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Point2D$3e$__["Point2D"](point.x, point.y));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].polyline(points);
    }
    /**
     * rect
     *
     * @param {SVGRectElement} rect
     * @returns {module:kld-intersections.ShapeInfo}
     */ static rect(rect) {
        if (rect instanceof SVGRectElement === false) {
            throw new TypeError(`Expected SVGRectElement, but found ${rect}`);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].rectangle(rect.x.baseVal.value, rect.y.baseVal.value, rect.width.baseVal.value, rect.height.baseVal.value, rect.rx.baseVal.value, rect.ry.baseVal.value);
    }
    /**
     * element
     *
     * @param {SVGElement} element
     * @returns {module:kld-intersections.ShapeInfo}
     */ static element(element) {
        if (element instanceof SVGElement === false) {
            throw new TypeError(`Expected SVGElement, but found ${element}`);
        }
        /* eslint-disable-next-line prefer-destructuring */ const tagName = element.tagName;
        switch(tagName){
            case "circle":
                return SvgShapes.circle(element);
            case "ellipse":
                return SvgShapes.ellipse(element);
            case "line":
                return SvgShapes.line(element);
            case "path":
                return SvgShapes.path(element);
            case "polygon":
                return SvgShapes.polygon(element);
            case "polyline":
                return SvgShapes.polyline(element);
            case "rect":
                return SvgShapes.rect(element);
            default:
                throw new TypeError(`Unrecognized element type: '${tagName}'`);
        }
    }
}
const __TURBOPACK__default__export__ = SvgShapes;
}}),
"[project]/node_modules/kld-intersections/lib/IntersectionQuery.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 *
 *  IntersectionQuery.js
 *
 *  @copyright 2017 Kevin Lindsey
 * @module IntersectionQuery
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/lib/Vector2D.js [app-client] (ecmascript) <export default as Vector2D>");
;
/**
 * @namespace
 */ const IntersectionQuery = {};
/**
 *  pointInCircle
 *
 *  @param {module:kld-intersections.Point2D} point
 *  @param {module:kld-intersections.Point2D} center
 *  @param {number} radius
 *  @returns {boolean}
 */ IntersectionQuery.pointInCircle = function(point, center, radius) {
    const v = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$lib$2f$Vector2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Vector2D$3e$__["Vector2D"].fromPoints(center, point);
    return v.length() <= radius;
};
/**
 *  pointInEllipse
 *
 *  @param {module:kld-intersections.Point2D} point
 *  @param {module:kld-intersections.Point2D} center
 *  @param {number} radiusX
 *  @param {number} radiusY
 *  @returns {boolean}
 */ IntersectionQuery.pointInEllipse = function(point, center, radiusX, radiusY) {
    const len = point.subtract(center);
    return len.x * len.x / (radiusX * radiusX) + len.y * len.y / (radiusY * radiusY) <= 1;
};
/**
 *  pointInPolyline
 *
 *  @param {module:kld-intersections.Point2D} point
 *  @param {Array<module:kld-intersections.Point2D>} points
 */ IntersectionQuery.pointInPolyline = function(point, points) {
    const { length: len } = points;
    let counter = 0;
    let xInter;
    let p1 = points[0];
    for(let i = 1; i <= len; i++){
        const p2 = points[i % len];
        const minY = Math.min(p1.y, p2.y);
        const maxY = Math.max(p1.y, p2.y);
        const maxX = Math.max(p1.x, p2.x);
        if (p1.y !== p2.y && minY < point.y && point.y <= maxY && point.x <= maxX) {
            xInter = (point.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
            if (p1.x === p2.x || point.x <= xInter) {
                counter++;
            }
        }
        p1 = p2;
    }
    return counter % 2 === 1;
};
/**
 *  pointInPolyline
 *
 *  @param {module:kld-intersections.Point2D} point
 *  @param {Array<module:kld-intersections.Point2D>} points
 */ IntersectionQuery.pointInPolygon = IntersectionQuery.pointInPolyline;
/**
 *  pointInRectangle
 *
 *  @param {module:kld-intersections.Point2D} point
 *  @param {module:kld-intersections.Point2D} topLeft
 *  @param {module:kld-intersections.Point2D} bottomRight
 *  @returns {boolean}
 */ IntersectionQuery.pointInRectangle = function(point, topLeft, bottomRight) {
    return topLeft.x <= point.x && point.x < bottomRight.x && topLeft.y <= point.y && point.y < bottomRight.y;
};
const __TURBOPACK__default__export__ = IntersectionQuery;
}}),
"[project]/node_modules/kld-intersections/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @module kld-intersections
 */ __turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$Intersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/Intersection.js [app-client] (ecmascript)");
/**
 * @deprecated Use ShapeInfo instead
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)");
/**
 * @namespace Shapes
 * @implements {module:Shapes~Shapes}
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$Shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/Shapes.js [app-client] (ecmascript)");
/**
 * @namespace AffineShapes
 * @implements {module:AffineShapes~AffineShapes}
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$AffineShapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/AffineShapes.js [app-client] (ecmascript)");
/**
 * @namespace SvgShapes
 * @implements {module:SvgShapes~SvgShapes}
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$SvgShapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/SvgShapes.js [app-client] (ecmascript)");
/**
 * @namespace IntersectionQuery
 * @implements {module:IntersectionQuery~IntersectionQuery}
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$IntersectionQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/IntersectionQuery.js [app-client] (ecmascript)");
// Expose affine module classes
/**
* @external Point2D
*/ /**
* @external Vector2D
*/ /**
* @external Matrix2D
*/ /**
 * @class Point2D
 * @memberof module:kld-intersections
 * @implements {external:Point2D}
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
;
;
;
;
;
;
;
;
;
;
 /**
* @external Polynomial
*/ }}),
"[project]/node_modules/kld-intersections/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$Intersection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/Intersection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$ShapeInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/ShapeInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$Shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/Shapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$AffineShapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/AffineShapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$SvgShapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/SvgShapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$IntersectionQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/IntersectionQuery.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$affine$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-affine/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/kld-intersections/lib/IntersectionQuery.js [app-client] (ecmascript) <export default as IntersectionQuery>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IntersectionQuery": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$IntersectionQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kld$2d$intersections$2f$lib$2f$IntersectionQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/kld-intersections/lib/IntersectionQuery.js [app-client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_kld-intersections_7dfe1a7b._.js.map